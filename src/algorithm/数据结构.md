# 数据结构

## 一.基础

### 1.背包,队列和栈

#### 背包

```java
public class Bag<Item> implements Iterable<Item> {
    private class Node {
        Item item;
        Node next;
    }

    private Node first;
    private int size;

    public int size() {
        return size;
    }

    public void add(Item item) {
        Node oldFirst = first;
        first = new Node();
        first.item = item;
        first.next = oldFirst;
        size++;
    }

    public Iterator<Item> iterator() {
        return new ListIterator();
    }

    private class ListIterator implements Iterator<Item> {
        private Node current = first;

        public boolean hasNext() {
            return current != null;
        }

        public void remove() {
            //Not used in Bag
        }

        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}

```

#### 栈

```Java
public class Stack<Item> implements Iterable<Item> {
    private class Node {
        Item item;
        Node next;
    }

    private Node first;
    private int size;

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public void push(Item item) {
        if (item == null) {
            throw new IllegalArgumentException("Item cannot be null");
        }
        Node newNode = new Node();
        newNode.item = item;
        newNode.next = first;
        first = newNode;
        size++;
    }

    public Item pop() {
        if (isEmpty()) {
            throw new RuntimeException("Stack underflow");
        }
        Item item = first.item;
        first = first.next;
        size--;
        return item;
    }

    public Item peek() {
        if (isEmpty()) {
            return null;
        }
        return first.item;
    }

    public Iterator<Item> iterator() {
        return new StackIterator();
    }

    private class StackIterator implements Iterator<Item> {
        private Node current = first;

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}
```

#### 队列

```java
public class Queue<Item> implements Iterable<Item> {
    private class Node {
        Item item;
        Node next;
    }

    private Node first;
    private Node last;
    private int size;

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public void enqueue(Item item) {
        if (item == null) {
            throw new IllegalArgumentException("Item cannot be null");
        }
        Node oldLast = last;
        last = new Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) {
            first = last;
        } else {
            oldLast.next = last;
        }
        size++;
    }

    public Item dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("Queue underflow");
        }
        Item item = first.item;
        first = first.next;
        size--;
        if (isEmpty()) {
            last = null;
        }
        return item;
    }

    public Item peek() {
        if (isEmpty()) {
            throw new RuntimeException("Queue underflow");
        }
        return first.item;
    }

    public Iterator<Item> iterator() {
        return new QueueIterator();
    }

    private class QueueIterator implements Iterator<Item> {
        private Node current = first;

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public Item next() {
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}
```

### 2.算法分析

#### 二分查找

```Java
public class BinarySearch {

    public static int binarySearch(int[] array, int target) {
        if (array == null) {
            return -1;
        }

        int low = 0;
        int high = array.length - 1;

        while (low <= high) {
            int middle = low + (high - low) / 2;

            if (array[middle] < target) {
                low = middle + 1;
            } else if (array[middle] > target) {
                high = middle - 1;
            } else {
                return middle;
            }
        }

        return -1;
    }

}
```

### 3.案例研究

UF接口

```Java
public interface UF {

    int count();
    int find(int site);
    boolean connected(int site1, int site2);
    void union(int site1, int site2);

}
```

#### 加权UF算法

```Java
public class WeightedQuickUnion implements UF{

    private int id[];
    private int size[];
    private int count;

    public WeightedQuickUnion(int size) {
        id = new int[size];
        this.size = new int[size];
        count = size;

        for (int i = 0; i < id.length; i++) {
            id[i] = i;
            this.size[i] = 1;
        }
    }

    public int count() {
        return count;
    }

    public boolean connected(int site1, int site2) {
        return find(site1) == find(site2);
    }

    // O(lg n)
    public int find(int site) {
        while (site != id[site]) {
            site = id[site];
        }

        return site;
    }

    // O(lg n)
    public void union(int site1, int site2) {
        int parentId1 = find(site1);
        int parentId2 = find(site2);

        if (parentId1 == parentId2) {
            return;
        }

        if (size[parentId1] < size[parentId2]) {
            id[parentId1] = parentId2;
            size[parentId2] += size[parentId1];
        } else {
            id[parentId2] = parentId1;
            size[parentId1] += size[parentId2];
        }

        count--;
    }

    public int[] getSizes() {
        return size;
    }
}
```

## 二.排序

### 1.初级排序算法

#### 插入排序

```Java
public class InsertionSort {

    public static void insertionSort(Comparable[] array) {

        for (int i = 0; i < array.length; i++) {
            for (int j = i; j > 0 && array[j - 1].compareTo(array[j]) > 0; j--) {
                Comparable temp = array[j];
                array[j] = array[j - 1];
                array[j - 1] = temp;
            }
        }
    }

    public static void insertionSort(Comparable[] array, int low, int high) {
        for (int i = low; i <= high; i++) {
            for (int j = i; j > 0 && ArrayUtil.more(array[j - 1], array[j]); j--) {
                Comparable temp = array[j];
                array[j] = array[j - 1];
                array[j - 1] = temp;
            }
        }
    }
}
```

#### 选择排序

```Java
public class SelectionSort {

    public static void selectionSort(Comparable[] array) {
        for (int i = 0; i < array.length; i++) {
            int minIndex = i;

            for (int j = i + 1; j < array.length; j++) {
                if (array[j].compareTo(array[minIndex]) < 0) {
                    minIndex = j;
                }
            }

            Comparable temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }
    }
}
```

#### 希尔排序

```Java
public class ShellSort {

    public static void shellSort(Comparable[] array) {
        int incrementSequence = 1;

        while (incrementSequence * 3 + 1 < array.length) {
            incrementSequence *= 3;
            incrementSequence++;
        }

        while (incrementSequence > 0) {

            for (int i = incrementSequence; i < array.length; i++) {
                for (int j = i; j >= incrementSequence && array[j].compareTo(array[j - incrementSequence]) < 0; j -= incrementSequence) {
                    Comparable temp = array[j];
                    array[j] = array[j - incrementSequence];
                    array[j - incrementSequence] = temp;
                }
            }
            incrementSequence /= 3;
        }
    }
}
```

### 2.归并排序

#### 自顶向下

```
public class TopDownMergeSort {

    public static void mergeSort(Comparable[] array) {
        Comparable[] aux = new Comparable[array.length];

        sort(array, aux, 0, array.length - 1);
    }

    private static void sort(Comparable[] array, Comparable[] aux, int low, int high) {

        if (high <= low) {
            return;
        }

        int middle = low + (high - low) / 2;

        sort(array, aux, low, middle);
        sort(array, aux, middle + 1, high);

        merge(array, aux, low, middle, high);
    }

    @SuppressWarnings("unchecked")
    private static void merge(Comparable[] array, Comparable[] aux, int low, int middle, int high) {
        for (int i = low; i <= high; i++) {
            aux[i] = array[i];
        }

        int indexLeft = low;
        int indexRight = middle + 1;
        int arrayIndex = low;

        while (indexLeft <= middle && indexRight <= high) {
            if (aux[indexLeft].compareTo(aux[indexRight]) <= 0) {
                array[arrayIndex] = aux[indexLeft];
                indexLeft++;
            } else {
                array[arrayIndex] = aux[indexRight];
                indexRight++;
            }
            arrayIndex++;
        }

        while (indexLeft <= middle) {
            array[arrayIndex] = aux[indexLeft];

            indexLeft++;
            arrayIndex++;
        }
    }
}
```

#### 自底向上

```Java
public class BottomUpMergeSort {

    public static void mergeSort(Comparable[] array) {
        Comparable[] aux = new Comparable[array.length];

        for (int size = 1; size < array.length; size = size + size) {
            for (int low = 0; low + size < array.length; low += size + size) {
                int high = Math.min(low + size + size - 1, array.length - 1);
                merge(array, aux, low, low + size - 1, high);
            }
        }
    }

    @SuppressWarnings("unchecked")
    public static void merge (Comparable[] array, Comparable[] aux, int low, int middle, int high) {
        for (int i = low; i <= high; i++) {
            aux[i] = array[i];
        }

        int leftIndex = low;
        int rightIndex = middle + 1;
        int arrayIndex = low;

        while (leftIndex <= middle && rightIndex <= high) {
            if (aux[leftIndex].compareTo(aux[rightIndex]) <= 0) {
                array[arrayIndex] = aux[leftIndex];
                leftIndex++;
            } else {
                array[arrayIndex] = aux[rightIndex];
                rightIndex++;
            }

            arrayIndex++;
        }

        while (leftIndex <= middle) {
            array[arrayIndex] = aux[leftIndex];
            leftIndex++;
            arrayIndex++;
        }
    }
}
```

### 3.快速排序

#### 快速排序

```Java
public class QuickSort {

    public static void quickSort(Comparable[] array) {
        StdRandom.shuffle(array);
        quickSort(array, 0, array.length - 1);
    }

    private static void quickSort(Comparable[] array, int low, int high) {

        if (low >= high) {
            return;
        }

        int partition = partition(array, low, high);
        quickSort(array, low, partition - 1);
        quickSort(array, partition + 1, high);
    }

    private static int partition(Comparable[] array, int low, int high) {
        Comparable pivot = array[low];

        int lowIndex = low;
        int highIndex = high + 1;

        while (true) {
            while (ArrayUtil.less(array[++lowIndex], pivot)) {
                if (lowIndex == high) {
                    break;
                }
            }

            while (ArrayUtil.less(pivot, array[--highIndex])) {
                if (highIndex == low) {
                    break;
                }
            }

            if (lowIndex >= highIndex) {
                break;
            }

            ArrayUtil.exchange(array, lowIndex, highIndex);
        }

        // Place pivot in the right place
        ArrayUtil.exchange(array, low, highIndex);
        return highIndex;
    }
}
```

#### 三切分快速排序

```Java
public class QuickSort3Way {

    public static void quickSort3Way(Comparable[] array) {
        StdRandom.shuffle(array);
        quickSort3Way(array, 0, array.length - 1);
    }

    @SuppressWarnings("unchecked")
    private static void quickSort3Way(Comparable[] array, int low, int high) {
        if (low >= high) {
            return;
        }

        int lowerThan = low;
        int i = low + 1;
        int greaterThan = high;

        Comparable pivot = array[low];

        while (i <= greaterThan) {
            int compare = array[i].compareTo(pivot);

            if (compare < 0) {
                ArrayUtil.exchange(array, lowerThan, i);
                lowerThan++;
                i++;
            } else if (compare > 0) {
                ArrayUtil.exchange(array, i, greaterThan);
                greaterThan--;
            } else {
                i++;
            }
        }

        // Now array[low..lowerThan - 1] < pivot = array[lowerThan..greaterThan] < array[greaterThan + 1..high]
        quickSort3Way(array, low, lowerThan - 1);
        quickSort3Way(array, greaterThan + 1, high);
    }

}
```

### 4.优先队列

#### 优先队列

```Java
public class PriorityQueue<Key extends Comparable<Key>> {

    enum Orientation {
        MAX, MIN;
    }

    private Key[] priorityQueue; // heap-ordered complete binary tree
    private int size = 0; // in priorityQueue[1..n] with pq[0] unused
    private Orientation orientation;

    public PriorityQueue(int size, Orientation orientation) {
        priorityQueue = (Key[]) new Comparable[size + 1];
        this.orientation = orientation;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public void insert(Key key) {
        if (size != priorityQueue.length - 1) {
            size++;

            priorityQueue[size] = key;
            swim(size);
        }
    }

    public Key peek() {
        if (size == 0) {
            throw new RuntimeException("Priority queue underflow");
        }
        return priorityQueue[1];
    }

    public Key deleteTop() {
        if (size == 0) {
            throw new RuntimeException("Priority queue underflow");
        }

        size--;

        Key topElement = priorityQueue[1];
        ArrayUtil.exchange(priorityQueue, 1, size + 1);

        priorityQueue[size + 1] = null;
        sink(1);

        return topElement;
    }

    private void swim(int index) {
        while (index / 2 >= 1) {
            if ((orientation == Orientation.MAX && ArrayUtil.less(priorityQueue[index / 2], priorityQueue[index]))
                    || (orientation == Orientation.MIN && ArrayUtil.more(priorityQueue[index / 2], priorityQueue[index]))) {
                ArrayUtil.exchange(priorityQueue, index / 2, index);
            } else {
                break;
            }

            index = index / 2;
        }
    }

    private void sink(int index) {
        while (index * 2 <= size) {
            int selectedChildIndex = index * 2;

            if (index * 2 + 1 <= size &&
                    (
                    (orientation == Orientation.MAX && ArrayUtil.less(priorityQueue[index * 2], priorityQueue[index * 2 + 1]))
                    || (orientation == Orientation.MIN && ArrayUtil.more(priorityQueue[index * 2], priorityQueue[index * 2 + 1]))
                    )
                    ) {
                selectedChildIndex = index * 2 + 1;
            }

            if ((orientation == Orientation.MAX && ArrayUtil.more(priorityQueue[selectedChildIndex], priorityQueue[index]))
                || (orientation == Orientation.MIN && ArrayUtil.less(priorityQueue[selectedChildIndex], priorityQueue[index]))) {
                ArrayUtil.exchange(priorityQueue, index, selectedChildIndex);
            } else {
                break;
            }

            index = selectedChildIndex;
        }
    }

}
```

#### 索引优先队列

```java
public class IndexMinPriorityQueue<Key extends Comparable<Key>> {

    private Key[] keys;
    private int[] pq; // Holds the indices of the keys
    private int[] qp; // Inverse of pq -> qp[i] gives the position of i in pq[] (the index j such that pq[j] is i).
                      // qp[pq[i]] = pq[qp[i]] = i
    private int size = 0;

    @SuppressWarnings("unchecked")
    public IndexMinPriorityQueue(int size) {
        keys = (Key[]) new Comparable[size + 1];
        pq = new int[size + 1];
        qp = new int[size + 1];

        for (int index = 0; index < qp.length; index++) {
            qp[index] = -1;
        }
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public boolean contains(int index) {
        return qp[index] != -1;
    }

    // Return key associated with index
    public Key keyOf(int index) {
        if (!contains(index)) {
            throw new NoSuchElementException("Index is not in the priority queue");
        }

        return keys[index];
    }

    public void insert(int index, Key key) {
        if (contains(index)) {
            throw new IllegalArgumentException("Index is already in the priority queue");
        }

        if (size != keys.length - 1) {
            size++;

            keys[index] = key;
            pq[size] = index;
            qp[index] = size;

            swim(size);
        }
    }

    // Remove a minimal key and return its index
    public int deleteMin() {
        if (size == 0) {
            throw new NoSuchElementException("Priority queue underflow");
        }

        int minElementIndex = pq[1];
        exchange(1, size);
        size--;
        sink(1);

        keys[pq[size + 1]] = null;
        qp[pq[size + 1]] = -1;

        return minElementIndex;
    }

    public void delete(int i) {
        if (!contains(i)) {
            throw new NoSuchElementException("Index is not in the priority queue");
        }

        int index = qp[i];

        exchange(index, size);
        size--;

        swim(index);
        sink(index);

        keys[i] = null; // Same thing as keys[pq[size + 1]] = null
        qp[i] = -1;     // Same thing as qp[pq[size + 1]] = -1;
    }

    // Change the key associated with index to key argument
    public void changeKey(int index, Key key) {
        if (!contains(index)) {
            throw new NoSuchElementException("Index is not in the priority queue");
        }

        keys[index] = key;

        swim(qp[index]);
        sink(qp[index]);
    }

    public void decreaseKey(int index, Key key) {
        if (!contains(index)) {
            throw new NoSuchElementException("Index is not in the priority queue");
        }
        if (key.compareTo(keys[index]) >= 0) {
            throw new IllegalArgumentException("Calling decreaseKey() with given argument would not strictly decrease the key");
        }

        keys[index] = key;
        swim(qp[index]);
    }

    public void increaseKey(int index, Key key) {
        if (!contains(index)) {
            throw new NoSuchElementException("Index is not in the priority queue");
        }
        if (key.compareTo(keys[index]) <= 0) {
            throw new IllegalArgumentException("Calling increaseKey() with given argument would not strictly increase the key");
        }

        keys[index] = key;
        sink(qp[index]);
    }

    public Key minKey() {
        if (size == 0) {
            throw new NoSuchElementException("Priority queue underflow");
        }

        return keys[pq[1]];
    }

    public int minIndex() {
        if (size == 0) {
            throw new NoSuchElementException("Priority queue underflow");
        }

        return pq[1];
    }

    private void swim(int index) {
        while (index / 2 >= 1 && more(index / 2, index)) {
            exchange(index / 2, index);
            index = index / 2;
        }
    }

    private void sink(int index) {
        while (index * 2 <= size) {
            int selectedChildIndex = index * 2;

            if (index * 2 + 1 <= size && more(index * 2, index * 2 + 1)) {
                selectedChildIndex = index * 2 + 1;
            }

            if (less(selectedChildIndex, index)) {
                exchange(index, selectedChildIndex);
            } else {
                break;
            }
            index = selectedChildIndex;
        }
    }

    private boolean less(int keyIndex1, int keyIndex2) {
        return keys[pq[keyIndex1]].compareTo(keys[pq[keyIndex2]]) < 0;
    }

    private boolean more(int keyIndex1, int keyIndex2) {
        return keys[pq[keyIndex1]].compareTo(keys[pq[keyIndex2]]) > 0;
    }

    private void exchange(int keyIndex1, int keyIndex2) {
        int temp = pq[keyIndex1];
        pq[keyIndex1] = pq[keyIndex2];
        pq[keyIndex2] = temp;

        qp[pq[keyIndex1]] = keyIndex1;
        qp[pq[keyIndex2]] = keyIndex2;
    }
}
```

#### 堆排序

```Java
public class HeapSort {

    public static void heapSort(Comparable[] array) {
        constructHeap(array);
        sortdown(array);
    }

    private static void constructHeap(Comparable[] array) {
        for (int i = array.length / 2; i >= 1; i--) {
            sink(array, i, array.length - 1);
        }
    }

    private static void sortdown(Comparable[] array) {
        int endIndex = array.length - 1;

        while (endIndex > 1) {
            ArrayUtil.exchange(array, 1, endIndex);
            endIndex--;
            sink(array, 1, endIndex);
        }
    }

    private static void sink(Comparable[] array, int index, int endIndex) {
        while (index * 2 <= endIndex) {
            int biggestChildIndex = index * 2;

            if (index * 2 + 1 <= endIndex
                    && ArrayUtil.more(array[index * 2 + 1], array[index * 2])) {
                biggestChildIndex = index * 2 + 1;
            }

            if (ArrayUtil.less(array[index], array[biggestChildIndex])) {
                ArrayUtil.exchange(array, index, biggestChildIndex);
            } else {
                break;
            }
            index = biggestChildIndex;
        }
    }
}
```

### 总结

各种排序算法的性能特点

| 算法         | 是否稳定 | 是否是原地排序 | 时间复杂度                 | 空间复杂度 | 备注                                               |
| ------------ | -------- | -------------- | -------------------------- | ---------- | -------------------------------------------------- |
| 选择排序     | 否       | 是             | *N*2                       | 1          |                                                    |
| 插入排序     | 是       | 是             | 介于 *N* 和 *N*2 之间      | 1          | 取决于输入元素的排列情                             |
| 希尔排序     | 否       | 是             | *N*log*N*?                 | 1          |                                                    |
| 快速排序     | 否       | 是             | *N*log*N*                  | lg*N*      | 运行效率由概率提供保证                             |
| 三向快速排序 | 否       | 是             | 介于*N* 和 *N*log*N*  之间 | lg*N*      | 运行效率由概率保证，同时也取决于输入元素的分布情况 |
| 归并排序     | 是       | 否             | *N*log*N*                  | *N*        |                                                    |
| 堆排序       | 否       | 是             | *N*log*N*                  | 1          |                                                    |

## 三.查找

### 1.符号表

链表（顺序查找） SequentialSearchST

有序数组（二分查找）BinarySearchST

### 2.二叉查找树

#### 二叉查找树

```Java
public class BinarySearchTree<Key extends Comparable<Key>, Value> implements SymbolTable<Key, Value> {

    protected class Node {
        protected Key key;
        protected Value value;

        protected Node left;
        protected Node right;

        protected int size; //# of nodes in subtree rooted here

        public Node(Key key, Value value, int size) {
            this.key = key;
            this.value = value;
            this.size = size;
        }
    }

    protected Node root;

    public int size() {
        return size(root);
    }

    protected int size(Node node) {
        if (node == null) {
            return 0;
        }

        return node.size;
    }

    public boolean isEmpty() {
        return size(root) == 0;
    }

    public Value get(Key key) {
        if (key == null) {
            return null;
        }

        return get(root, key);
    }

    private Value get(Node node, Key key) {
        if (node == null) {
            return null;
        }

        int compare = key.compareTo(node.key);
        if (compare < 0) {
            return get(node.left, key);
        } else if (compare > 0) {
            return get(node.right, key);
        } else {
            return node.value;
        }
    }

    public boolean contains(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Argument to contains() cannot be null");
        }
        return get(key) != null;
    }

    public void put(Key key, Value value) {
        if (key == null) {
            return;
        }

        if (value == null) {
            delete(key);
            return;
        }

        root = put(root, key, value);
    }

    private Node put(Node node, Key key, Value value) {
        if (node == null) {
            return new Node(key, value, 1);
        }

        int compare = key.compareTo(node.key);

        if (compare < 0) {
            node.left = put(node.left, key, value);
        } else if (compare > 0) {
            node.right = put(node.right, key, value);
        } else {
            node.value = value;
        }

        node.size = size(node.left) + 1 + size(node.right);
        return node;
    }

    public Key min() {
        if (root == null) {
            throw new NoSuchElementException("Empty binary search tree");
        }

        return min(root).key;
    }

    private Node min(Node node) {
        if (node.left == null) {
            return node;
        }

        return min(node.left);
    }

    public Key max() {
        if (root == null) {
            throw new NoSuchElementException("Empty binary search tree");
        }

        return max(root).key;
    }

    private Node max(Node node) {
        if (node.right == null) {
            return node;
        }

        return max(node.right);
    }

    // Returns the highest key in the symbol table smaller than or equal to key.
    public Key floor(Key key) {
        Node node = floor(root, key);
        if (node == null) {
            return null;
        }

        return node.key;
    }

    private Node floor(Node node, Key key) {
        if (node == null) {
            return null;
        }

        int compare = key.compareTo(node.key);

        if (compare == 0) {
            return node;
        } else if (compare < 0) {
            return floor(node.left, key);
        } else {
            Node rightNode = floor(node.right, key);
            if (rightNode != null) {
                return rightNode;
            } else {
                return node;
            }
        }
    }

    // Returns the smallest key in the symbol table greater than or equal to key.
    public Key ceiling(Key key) {
        Node node = ceiling(root, key);
        if (node == null) {
            return null;
        }

        return node.key;
    }

    private Node ceiling(Node node, Key key) {
        if (node == null) {
            return null;
        }

        int compare = key.compareTo(node.key);

        if (compare == 0) {
            return node;
        } else if (compare > 0) {
            return ceiling(node.right, key);
        } else {
            Node leftNode = ceiling(node.left, key);
            if (leftNode != null) {
                return leftNode;
            } else {
                return node;
            }
        }
    }

    public Key select(int index) {
        if (index < 0 || index >= size()) {
            throw new IllegalArgumentException("Index cannot be negative and must be lower than tree size");
        }

        return select(root, index).key;
    }

    private Node select(Node node, int index) {
        int leftSubtreeSize = size(node.left);

        if (leftSubtreeSize == index) {
            return node;
        } else if (leftSubtreeSize > index) {
            return select(node.left, index);
        } else {
            return select(node.right, index - leftSubtreeSize - 1);
        }
    }

    public int rank(Key key) {
        return rank(root, key);
    }

    private int rank(Node node, Key key) {
        if (node == null) {
            return 0;
        }

        // Returns the number of keys less than node.key in the subtree rooted at node
        int compare = key.compareTo(node.key);
        if (compare < 0) {
            return rank(node.left, key);
        } else if (compare > 0) {
            return size(node.left) + 1 + rank(node.right, key);
        } else {
            return size(node.left);
        }
    }

    public void deleteMin() {
        if (root == null) {
            return;
        }

        root = deleteMin(root);
    }

    private Node deleteMin(Node node) {
        if (node.left == null) {
            return node.right;
        }

        node.left = deleteMin(node.left);
        node.size = size(node.left) + 1 + size(node.right);
        return node;
    }

    public void deleteMax() {
        if (root == null) {
            return;
        }

        root = deleteMax(root);
    }

    private Node deleteMax(Node node) {
        if (node.right == null) {
            return node.left;
        }

        node.right = deleteMax(node.right);
        node.size = size(node.left) + 1 + size(node.right);
        return node;
    }

    public void delete(Key key) {
        if (isEmpty()) {
            return;
        }

        if (!contains(key)) {
            return;
        }

        root = delete(root, key);
    }

    private Node delete(Node node, Key key) {
        int compare = key.compareTo(node.key);
        if (compare < 0) {
            node.left = delete(node.left, key);
        } else if (compare > 0) {
            node.right = delete(node.right, key);
        } else {
            if (node.left == null) {
                return node.right;
            } else if (node.right == null) {
                return node.left;
            } else {
                Node aux = node;
                node = min(aux.right);
                node.right = deleteMin(aux.right);
                node.left = aux.left;
            }
        }

        node.size = size(node.left) + 1 + size(node.right);
        return node;
    }

    public Iterable<Key> keys() {
        return keys(min(), max());
    }

    public Iterable<Key> keys(Key low, Key high) {
        if (low == null)  {
            throw new IllegalArgumentException("First argument to keys() cannot be null");
        }
        if (high == null) {
            throw new IllegalArgumentException("Second argument to keys() cannot be null");
        }

        Queue<Key> queue = new Queue<>();
        keys(root, queue, low, high);
        return queue;
    }

    private void keys(Node node, Queue<Key> queue, Key low, Key high) {
        if (node == null) {
            return;
        }

        int compareLow = low.compareTo(node.key);
        int compareHigh = high.compareTo(node.key);

        if (compareLow < 0) {
            keys(node.left, queue, low, high);
        }

        if (compareLow <= 0 && compareHigh >= 0) {
            queue.enqueue(node.key);
        }

        if (compareHigh > 0) {
            keys(node.right, queue, low, high);
        }
    }

    public int size(Key low, Key high) {
        if (low == null)  {
            throw new IllegalArgumentException("First argument to size() cannot be null");
        }
        if (high == null) {
            throw new IllegalArgumentException("Second argument to size() cannot be null");
        }

        if (low.compareTo(high) > 0) {
            return 0;
        }

        if (contains(high)) {
            return rank(high) - rank(low) + 1;
        } else {
            return rank(high) - rank(low);
        }
    }

}
```

### 3.平衡查找树

#### 红黑树

```java
public class RedBlackBST<Key extends Comparable<Key>, Value> {

    protected static final boolean RED = true;
    protected static final boolean BLACK = false;

    protected class Node {
        public Key key;
        public Value value;
        public Node left, right;

        boolean color;
        int size;

        Node(Key key, Value value, int size, boolean color) {
            this.key = key;
            this.value = value;

            this.size = size;
            this.color = color;
        }
    }

    protected Node root;

    public int size() {
        return size(root);
    }

    protected int size(Node node) {
        if (node == null) {
            return 0;
        }

        return node.size;
    }

    public boolean isEmpty() {
        return size(root) == 0;
    }

    protected boolean isRed(Node node) {
        if (node == null) {
            return false;
        }

        return node.color == RED;
    }

    protected Node rotateLeft(Node node) {
        if (node == null || node.right == null) {
            return node;
        }

        Node newRoot = node.right;

        node.right = newRoot.left;
        newRoot.left = node;

        newRoot.color = node.color;
        node.color = RED;

        newRoot.size = node.size;
        node.size = size(node.left) + 1 + size(node.right);

        return newRoot;
    }

    protected Node rotateRight(Node node) {
        if (node == null || node.left == null) {
            return node;
        }

        Node newRoot = node.left;

        node.left = newRoot.right;
        newRoot.right = node;

        newRoot.color = node.color;
        node.color = RED;

        newRoot.size = node.size;
        node.size = size(node.left) + 1 + size(node.right);

        return newRoot;
    }

    protected void flipColors(Node node) {
        if (node == null || node.left == null || node.right == null) {
            return;
        }

        //The root must have opposite color of its two children
        if ((isRed(node) && !isRed(node.left) && !isRed(node.right))
                || (!isRed(node) && isRed(node.left) && isRed(node.right))) {
            node.color = !node.color;
            node.left.color = !node.left.color;
            node.right.color = !node.right.color;
        }
    }

    public void put(Key key, Value value) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (value == null) {
            delete(key);
            return;
        }

        root = put(root, key, value);
        root.color = BLACK;
    }

    private Node put(Node node, Key key, Value value) {
        if (node == null) {
            return new Node(key, value, 1, RED);
        }

        int compare = key.compareTo(node.key);

        if (compare < 0) {
            node.left = put(node.left, key, value);
        } else if (compare > 0) {
            node.right = put(node.right, key, value);
        } else {
            node.value = value;
        }

        if (isRed(node.right) && !isRed(node.left)) {
            node = rotateLeft(node);
        }
        if (isRed(node.left) && isRed(node.left.left)) {
            node = rotateRight(node);
        }
        if (isRed(node.left) && isRed(node.right)) {
            flipColors(node);
        }

        node.size = size(node.left) + 1 + size(node.right);
        return node;
    }

    public Value get(Key key) {
        if (key == null) {
            return null;
        }

        return get(root, key);
    }

    private Value get(Node node, Key key) {
        if (node == null) {
            return null;
        }

        int compare = key.compareTo(node.key);
        if (compare < 0) {
            return get(node.left, key);
        } else if (compare > 0) {
            return get(node.right, key);
        } else {
            return node.value;
        }
    }

    public boolean contains(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Argument to contains() cannot be null");
        }
        return get(key) != null;
    }

    public Key min() {
        if (root == null) {
            throw new NoSuchElementException("Empty binary search tree");
        }

        return min(root).key;
    }

    protected Node min(Node node) {
        if (node.left == null) {
            return node;
        }

        return min(node.left);
    }

    public Key max() {
        if (root == null) {
            throw new NoSuchElementException("Empty binary search tree");
        }

        return max(root).key;
    }

    private Node max(Node node) {
        if (node.right == null) {
            return node;
        }

        return max(node.right);
    }

    //Returns the highest key in the symbol table smaller than or equal to key.
    public Key floor(Key key) {
        Node node = floor(root, key);
        if (node == null) {
            return null;
        }

        return node.key;
    }

    private Node floor(Node node, Key key) {
        if (node == null) {
            return null;
        }

        int compare = key.compareTo(node.key);

        if (compare == 0) {
            return node;
        } else if (compare < 0) {
            return floor(node.left, key);
        } else {
            Node rightNode = floor(node.right, key);
            if (rightNode != null) {
                return rightNode;
            } else {
                return node;
            }
        }
    }

    //Returns the smallest key in the symbol table greater than or equal to key.
    public Key ceiling(Key key) {
        Node node = ceiling(root, key);
        if (node == null) {
            return null;
        }

        return node.key;
    }

    private Node ceiling(Node node, Key key) {
        if (node == null) {
            return null;
        }

        int compare = key.compareTo(node.key);

        if (compare == 0) {
            return node;
        } else if (compare > 0) {
            return ceiling(node.right, key);
        } else {
            Node leftNode = ceiling(node.left, key);
            if (leftNode != null) {
                return leftNode;
            } else {
                return node;
            }
        }
    }

    public Key select(int index) {
        if (index >= size()) {
            throw new IllegalArgumentException("Index is higher than tree size");
        }

        return select(root, index).key;
    }

    private Node select(Node node, int index) {
        int leftSubtreeSize = size(node.left);

        if (leftSubtreeSize == index) {
            return node;
        } else if (leftSubtreeSize > index) {
            return select(node.left, index);
        } else {
            return select(node.right, index - leftSubtreeSize - 1);
        }
    }

    public int rank(Key key) {
        return rank(root, key);
    }

    private int rank(Node node, Key key) {
        if (node == null) {
            return 0;
        }

        //Returns the number of keys less than node.key in the subtree rooted at node
        int compare = key.compareTo(node.key);
        if (compare < 0) {
            return rank(node.left, key);
        } else if (compare > 0) {
            return size(node.left) + 1 + rank(node.right, key);
        } else {
            return size(node.left);
        }
    }

    public void deleteMin() {
        if (isEmpty()) {
            return;
        }

        if (!isRed(root.left) && !isRed(root.right)) {
            root.color = RED;
        }

        root = deleteMin(root);

        if (!isEmpty()) {
            root.color = BLACK;
        }
    }

    protected Node deleteMin(Node node) {
        if (node.left == null) {
            return null;
        }

        if (!isRed(node.left) && !isRed(node.left.left)) {
            node = moveRedLeft(node);
        }

        node.left = deleteMin(node.left);
        return balance(node);
    }

    public void deleteMax() {
        if (isEmpty()) {
            return;
        }

        if (!isRed(root.left) && !isRed(root.right)) {
            root.color = RED;
        }

        root = deleteMax(root);

        if (!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node deleteMax(Node node) {
        if (isRed(node.left)) {
            node = rotateRight(node);
        }

        if (node.right == null) {
            return null;
        }

        if (!isRed(node.right) && !isRed(node.right.left)) {
            node = moveRedRight(node);
        }

        node.right = deleteMax(node.right);
        return balance(node);
    }

    public void delete(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (isEmpty() || !contains(key)) {
            return;
        }

        if (!isRed(root.left) && !isRed(root.right)) {
            root.color = RED;
        }

        root = delete(root, key);

        if (!isEmpty()) {
            root.color = BLACK;
        }
    }

    private Node delete(Node node, Key key) {
        if (node == null) {
            return null;
        }

        if (key.compareTo(node.key) < 0) {
            if (!isRed(node.left) && node.left != null && !isRed(node.left.left)) {
                node = moveRedLeft(node);
            }

            node.left = delete(node.left, key);
        } else {
            if (isRed(node.left)) {
                node = rotateRight(node);
            }

            if (key.compareTo(node.key) == 0 && node.right == null) {
                return null;
            }

            if (!isRed(node.right) && node.right != null && !isRed(node.right.left)) {
                node = moveRedRight(node);
            }

            if (key.compareTo(node.key) == 0) {
                Node aux = min(node.right);
                node.key = aux.key;
                node.value = aux.value;
                node.right = deleteMin(node.right);
            } else {
                node.right = delete(node.right, key);
            }
        }

        return balance(node);
    }

    protected Node moveRedLeft(Node node) {
        //Assuming that node is red and both node.left and node.left.left are black,
        // make node.left or one of its children red
        flipColors(node);

        if (node.right != null && isRed(node.right.left)) {
            node.right = rotateRight(node.right);
            node = rotateLeft(node);
            flipColors(node);
        }

        return node;
    }

    protected Node moveRedRight(Node node) {
        //Assuming that node is red and both node.right and node.right.left are black,
        // make node.right or one of its children red
        flipColors(node);

        if (node.left != null && isRed(node.left.left)) {
            node = rotateRight(node);
            flipColors(node);
        }

        return node;
    }

    protected Node balance(Node node) {
        if (node == null) {
            return null;
        }

        if (isRed(node.right) && !isRed(node.left)) {
            node = rotateLeft(node);
        }

        if (isRed(node.left) && isRed(node.left.left)) {
            node = rotateRight(node);
        }

        if (isRed(node.left) && isRed(node.right)) {
            flipColors(node);
        }

        node.size = size(node.left) + 1 + size(node.right);

        return node;
    }

    public Iterable<Key> keys() {
        return keys(min(), max());
    }

    public Iterable<Key> keys(Key low, Key high) {
        if (low == null)  {
            throw new IllegalArgumentException("First argument to keys() cannot be null");
        }
        if (high == null) {
            throw new IllegalArgumentException("Second argument to keys() cannot be null");
        }

        Queue<Key> queue = new Queue<>();
        keys(root, queue, low, high);
        return queue;
    }

    private void keys(Node node, Queue<Key> queue, Key low, Key high) {
        if (node == null) {
            return;
        }

        int compareLow = low.compareTo(node.key);
        int compareHigh = high.compareTo(node.key);

        if (compareLow < 0) {
            keys(node.left, queue, low, high);
        }

        if (compareLow <= 0 && compareHigh >= 0) {
            queue.enqueue(node.key);
        }

        if (compareHigh > 0) {
            keys(node.right, queue, low, high);
        }
    }

    public int size(Key low, Key high) {
        if (low == null)  {
            throw new IllegalArgumentException("First argument to size() cannot be null");
        }
        if (high == null) {
            throw new IllegalArgumentException("Second argument to size() cannot be null");
        }

        if (low.compareTo(high) > 0) {
            return 0;
        }

        if (contains(high)) {
            return rank(high) - rank(low) + 1;
        } else {
            return rank(high) - rank(low);
        }
    }

}
```

### 4.散列表

#### 基于拉链法的散列表

```Java
public class SeparateChainingHashTable<Key, Value> {

    class SequentialSearchSymbolTable<Key, Value> {

        private class Node {
            Key key;
            Value value;
            Node next;

            public Node(Key key, Value value, Node next) {
                this.key = key;
                this.value = value;
                this.next = next;
            }
        }

        private Node first;
        protected int size;

        public int size() {
            return size;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public boolean contains(Key key) {
            return get(key) != null;
        }

        public Value get(Key key) {
            for (Node node = first; node != null; node = node.next) {
                if (key.equals(node.key)) {
                    return node.value;
                }
            }

            return null;
        }

        public void put(Key key, Value value) {
            for (Node node = first; node != null; node = node.next) {
                if (key.equals(node.key)) {
                    node.value = value;
                    return;
                }
            }

            first = new Node(key, value, first);
            size++;
        }

        public void delete(Key key) {
            if (first.key.equals(key)) {
                first = first.next;
                size--;
                return;
            }

            for (Node node = first; node != null; node = node.next) {
                if (node.next != null && node.next.key.equals(key)) {
                    node.next = node.next.next;
                    size--;
                    return;
                }
            }
        }

        public Iterable<Key> keys() {
            Queue<Key> keys = new Queue<>();

            for (Node node = first; node != null; node = node.next) {
                keys.enqueue(node.key);
            }

            return keys;
        }

    }

    protected int averageListSize;

    protected int size;
    protected int keysSize;
    SequentialSearchSymbolTable<Key, Value>[] symbolTable;

    private static final int DEFAULT_HASH_TABLE_SIZE = 997;
    private static final int DEFAULT_AVERAGE_LIST_SIZE = 5;

    // The largest prime <= 2^i for i = 1 to 31
    // Used to distribute keys uniformly in the hash table after resizes
    // PRIMES[n] = 2^k - Ak where k is the power of 2 and Ak is the value to subtract to reach the previous prime number
    protected static final int[] PRIMES = {
            1, 1, 3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381,
            32749, 65521, 131071, 262139, 524287, 1048573, 2097143, 4194301,
            8388593, 16777213, 33554393, 67108859, 134217689, 268435399,
            536870909, 1073741789, 2147483647
    };

    // The lg of the hash table size
    // Used in combination with PRIMES[] to distribute keys uniformly in the hash function after resizes
    protected int lgM;

    public SeparateChainingHashTable() {
        this(DEFAULT_HASH_TABLE_SIZE, DEFAULT_AVERAGE_LIST_SIZE);
    }

    public SeparateChainingHashTable(int initialSize, int averageListSize) {
        this.size = initialSize;
        this.averageListSize = averageListSize;
        symbolTable = new SequentialSearchSymbolTable[size];

        for (int i = 0; i < size; i++) {
            symbolTable[i] = new SequentialSearchSymbolTable<>();
        }
        lgM = (int) (Math.log(size) / Math.log(2));
    }

    public int size() {
        return keysSize;
    }

    public boolean isEmpty() {
        return keysSize == 0;
    }

    protected int hash(Key key) {
        int hash = key.hashCode() & 0x7fffffff;

        if (lgM < 26) {
            hash = hash % PRIMES[lgM + 5];
        }
        return hash % size;
    }

    protected double getLoadFactor() {
        return ((double) keysSize) / (double) size;
    }

    public boolean contains(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Argument to contains() cannot be null");
        }
        return get(key) != null;
    }

    public void resize(int newSize) {
        SeparateChainingHashTable<Key, Value> separateChainingHashTableTemp =
                new SeparateChainingHashTable<>(newSize, averageListSize);

        for (Key key : keys()) {
            separateChainingHashTableTemp.put(key, get(key));
        }

        symbolTable = separateChainingHashTableTemp.symbolTable;
        size = separateChainingHashTableTemp.size;
    }

    public Value get(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Argument to get() cannot be null");
        }

        return symbolTable[hash(key)].get(key);
    }

    public void put(Key key, Value value) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (value == null) {
            delete(key);
            return;
        }

        int hashIndex = hash(key);
        int currentSize = symbolTable[hashIndex].size;
        symbolTable[hashIndex].put(key, value);

        if (currentSize < symbolTable[hashIndex].size) {
            keysSize++;
        }

        if (getLoadFactor() > averageListSize) {
            resize(size * 2);
            lgM++;
        }
    }

    public void delete(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Argument to delete() cannot be null");
        }

        if (isEmpty() || !contains(key)) {
            return;
        }

        symbolTable[hash(key)].delete(key);
        keysSize--;

        if (size > 1 && getLoadFactor() <= averageListSize / (double) 4) {
            resize(size / 2);
            lgM--;
        }
    }

    public Iterable<Key> keys() {
        Queue<Key> keys = new Queue<>();

        for (SequentialSearchSymbolTable<Key, Value> sequentialSearchST : symbolTable) {
            for (Key key : sequentialSearchST.keys()) {
                keys.enqueue(key);
            }
        }
        return keys;
    }
}
```

#### 基于线性探测的散列表

```Java
public class LinearProbingHashTable<Key, Value> {

    protected int keysSize;
    protected int size;
    protected Key[] keys;
    protected Value[] values;

    // The largest prime <= 2^i for i = 1 to 31
    // Used to distribute keys uniformly in the hash table after resizes
    // PRIMES[n] = 2^k - Ak where k is the power of 2 and Ak is the value to subtract to reach the previous prime number
    private static final int[] PRIMES = {
            1, 1, 3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381,
            32749, 65521, 131071, 262139, 524287, 1048573, 2097143, 4194301,
            8388593, 16777213, 33554393, 67108859, 134217689, 268435399,
            536870909, 1073741789, 2147483647
    };

    // The lg of the hash table size
    // Used in combination with PRIMES[] to distribute keys uniformly in the hash function after resizes
    protected int lgM;

    public LinearProbingHashTable(int size) {
        this.size = size;
        keys = (Key[]) new Object[size];
        values = (Value[]) new Object[size];

        lgM = (int) (Math.log(size) / Math.log(2));
    }

    public int size() {
        return keysSize;
    }

    public boolean isEmpty() {
        return keysSize == 0;
    }

    protected int hash(Key key) {
        int hash = key.hashCode() & 0x7fffffff;

        if (lgM < 26) {
            hash = hash % PRIMES[lgM + 5];
        }

        return hash % size;
    }

    protected double getLoadFactor() {
        return keysSize / (double) size;
    }

    private void resize(int newSize) {
        LinearProbingHashTable<Key, Value> tempHashTable = new LinearProbingHashTable<>(newSize);

        for (int i = 0; i < size; i++) {
            if (keys[i] != null) {
                tempHashTable.put(keys[i], values[i]);
            }
        }

        keys = tempHashTable.keys;
        values = tempHashTable.values;
        size = tempHashTable.size;
    }

    public boolean contains(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Argument to contains() cannot be null");
        }

        return get(key) != null;
    }

    public Value get(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Argument to get() cannot be null");
        }

        for (int tableIndex = hash(key); keys[tableIndex] != null; tableIndex = (tableIndex + 1) % size) {
            if (keys[tableIndex].equals(key)) {
                return values[tableIndex];
            }
        }

        return null;
    }

    public void put(Key key, Value value) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (value == null) {
            delete(key);
            return;
        }

        if (keysSize >= size / (double) 2) {
            resize(size * 2);
            lgM++;
        }

        int tableIndex;
        for (tableIndex = hash(key); keys[tableIndex] != null; tableIndex = (tableIndex + 1) % size) {
            if (keys[tableIndex].equals(key)) {
                values[tableIndex] = value;
                return;
            }
        }

        keys[tableIndex] = key;
        values[tableIndex] = value;
        keysSize++;
    }

    public void delete(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("Argument to delete() cannot be null");
        }

        if (!contains(key)) {
            return;
        }

        int tableIndex = hash(key);
        while (!keys[tableIndex].equals(key)) {
            tableIndex = (tableIndex + 1) % size;
        }

        keys[tableIndex] = null;
        values[tableIndex] = null;
        keysSize--;

        tableIndex = (tableIndex + 1) % size;

        while (keys[tableIndex] != null) {
            Key keyToRedo = keys[tableIndex];
            Value valueToRedo = values[tableIndex];

            keys[tableIndex] = null;
            values[tableIndex] = null;
            keysSize--;

            put(keyToRedo, valueToRedo);
            tableIndex = (tableIndex + 1) % size;
        }

        if (keysSize > 1 && keysSize <= size / (double) 8) {
            resize(size / 2);
            lgM--;
        }
    }

    public Iterable<Key> keys() {
        Queue<Key> keySet = new Queue<>();

        for (Object key : keys) {
            if (key != null) {
                keySet.enqueue((Key) key);
            }
        }
        return keySet;
    }
}
```

### 5.总结

各种符号表实现的渐进性能的总结

| 算法(数据结构)           | 查找(最坏情况) | 插入(最坏情况) | 查找(平均情况) | 插入(平均情况) | 关键接口            | 内存使用(字节)         |
| ------------------------ | -------------- | -------------- | -------------- | -------------- | ------------------- | ---------------------- |
| 顺序查询（无序链表）     | *N*            | *N*            | *N*/2          | *N*            | equals()            | 48*N*                  |
| 二分查找（有序数组）     | lg*N*          | *N*            | lg*N*          | *N*/2          | compareTo()         | 16*N*                  |
| 二叉树查找（二叉查找树） | *N*            | *N*            | 1.39lg*N*      | 1.39lg*N*      | compareTo()         | 64*N*                  |
| 2-3 树查找（红黑树）     | 2lg*N*         | 2lg*N*         | 1.00lg*N*      | 1.00lg*N*      | compareTo()         | 64*N*                  |
| 拉链法*（链表数组）      | <lg*N*         | <lg*N*         | *N*/(2*M*)     | *N*/*M*        | equals() hashCode() | 48*N*+32*M*            |
| 线性探测法（* 并行数组） | *c*lg*N*       | *c*lg*N*       | <1.5           | <2.5           | equals() hashCode() | 在 32*N* 和128*N* 之间 |

\* 需要均匀并独立的散列函数。

## 四.图

### 1.无向图

图的接口

```Java
public interface GraphInterface {

    int vertices();
    int edges();
    Iterable<Integer> adjacent(int vertex);

}
```

#### 无向图

```Java
public class Graph implements GraphInterface {

    private final int vertices;
    protected int edges;
    private Bag<Integer>[] adjacent;

    public Graph(int vertices) {
        this.vertices = vertices;
        this.edges = 0;
        adjacent = (Bag<Integer>[]) new Bag[vertices];

        for (int vertex = 0; vertex < vertices; vertex++) {
            adjacent[vertex] = new Bag<>();
        }
    }

    public Graph(In in) {
        this(in.readInt());
        int edges = in.readInt();

        for (int i = 0; i < edges; i++) {
            int vertex1 = in.readInt();
            int vertex2 = in.readInt();
            addEdge(vertex1, vertex2);
        }
    }

    public int vertices() {
        return vertices;
    }

    public int edges() {
        return edges;
    }

    public void addEdge(int vertex1, int vertex2) {
        adjacent[vertex1].add(vertex2);
        adjacent[vertex2].add(vertex1);
        edges++;
    }

    public Bag<Integer>[] getAdjacencyList() {
        return adjacent;
    }

    public void updateAdjacencyList(int vertex, Bag adjacencyList) {
        adjacent[vertex] = adjacencyList;
    }

    public Iterable<Integer> adjacent(int vertex) {
        return adjacent[vertex];
    }

    public int degree(int vertex) {
        return adjacent[vertex].size();
    }

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();

        for (int vertex = 0; vertex < vertices(); vertex++) {
            stringBuilder.append(vertex).append(": ");

            for (int neighbor : adjacent(vertex)) {
                stringBuilder.append(neighbor).append(" ");
            }
            stringBuilder.append("\n");
        }

        return stringBuilder.toString();
    }
}
```

#### 深度优先搜索(DFS)

```
public class DepthFirstSearch {
    private boolean[] visited;
    private int count;

    public DepthFirstSearch(Graph graph, int sourceVertex) {
        visited = new boolean[graph.vertices()];
        dfs(graph, sourceVertex);
    }

    private void dfs(Graph graph, int vertex) {
        visited[vertex] = true;
        count++;

        for (int neighbor : graph.adjacent(vertex)) {
            if (!visited[neighbor]) {
                dfs(graph, neighbor);
            }
        }
    }

    public boolean marked(int vertex) {
        return visited[vertex];
    }

    public int count() {
        return count;
    }
}
```

#### 单点最短路径

```Java
public class BreadthFirstPaths {

    private boolean[] visited;
    private int[] edgeTo;
    private final int source;

    private int[] distTo;

    public BreadthFirstPaths(GraphInterface graph, int source) {
        visited = new boolean[graph.vertices()];
        edgeTo = new int[graph.vertices()];
        this.source = source;

        distTo = new int[graph.vertices()];

        distTo[source] = 0;
        for (int vertex = 0; vertex < graph.vertices(); vertex++) {
            if (vertex == source) {
                continue;
            }
            distTo[vertex] = Integer.MAX_VALUE;
        }
        bfs(graph, source);
    }

    private void bfs(GraphInterface graph, int sourceVertex) {
        Queue<Integer> queue = new Queue<>();
        visited[sourceVertex] = true;

        queue.enqueue(sourceVertex);

        while (!queue.isEmpty()) {
            int currentVertex = queue.dequeue();

            for (int neighbor : graph.adjacent(currentVertex)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;

                    edgeTo[neighbor] = currentVertex;
                    distTo[neighbor] = distTo[currentVertex] + 1;

                    queue.enqueue(neighbor);
                }
            }
        }
    }

    // O(1)
    public int distTo(int vertex) {
        return distTo[vertex];
    }

    // O(1)
    public int edgeTo(int vertex) {
        return edgeTo[vertex];
    }

    public boolean hasPathTo(int vertex) {
        return visited[vertex];
    }

    public Iterable<Integer> pathTo(int vertex) {
        if (!hasPathTo(vertex)) {
            return null;
        }

        Stack<Integer> path = new Stack<>();

        for (int currentVertex = vertex; currentVertex != source; currentVertex = edgeTo[currentVertex]) {
            path.push(currentVertex);
        }

        path.push(source);
        return path;
    }
}
```

#### 单点路径

```Java
public class DepthFirstPaths {

    private boolean[] visited;
    private int[] edgeTo;
    private final int source;

    public DepthFirstPaths(GraphInterface graph, int source) {
        visited = new boolean[graph.vertices()];
        edgeTo = new int[graph.vertices()];
        this.source = source;
        dfs(graph, source);
    }

    private void dfs(GraphInterface graph, int vertex) {
        visited[vertex] = true;

        for (int neighbor : graph.adjacent(vertex)) {
            if (!visited[neighbor]) {
                edgeTo[neighbor] = vertex;
                dfs(graph, neighbor);
            }
        }
    }

    public boolean hasPathTo(int vertex) {
        return visited[vertex];
    }

    public Iterable<Integer> pathTo(int vertex) {
        if (!hasPathTo(vertex)) {
            return null;
        }

        Stack<Integer> path = new Stack<>();

        for (int currentVertex = vertex; currentVertex != source; currentVertex = edgeTo[currentVertex]) {
            path.push(currentVertex);
        }

        path.push(source);
        return path;
    }
}
```

#### 连通性CC

连通接口

```Java
public interface ConnectedComponents {

    boolean connected(int vertex1, int vertex2);
    int id(int vertex);
    int count();

}
```



```Java
public class ConnectedComponentsIterativeDFS implements ConnectedComponents {

    private boolean[] visited;
    private int[] id;
    private int count;

    public ConnectedComponentsIterativeDFS(Graph graph) {
        visited = new boolean[graph.vertices()];
        id = new int[graph.vertices()];

        for (int source = 0; source < graph.vertices(); source++) {
            if (!visited[source]) {
                depthFirstSearchIterative(graph, source);
                count++;
            }
        }
    }

    private void depthFirstSearchIterative(Graph graph, int sourceVertex) {
        Stack<Integer> stack = new Stack<>();
        stack.push(sourceVertex);
        visited[sourceVertex] = true;
        id[sourceVertex] = count;

        // Used to be able to iterate over each adjacency list, keeping track of which
        // vertex in each adjacency list needs to be explored next
        Iterator<Integer>[] adjacentIterators = (Iterator<Integer>[]) new Iterator[graph.vertices()];

        for (int vertexId = 0; vertexId < adjacentIterators.length; vertexId++) {
            if (graph.getAdjacencyList()[vertexId] != null) {
                adjacentIterators[vertexId] = graph.getAdjacencyList()[vertexId].iterator();
            }
        }

        while (!stack.isEmpty()) {
            int currentVertex = stack.peek();

            if (adjacentIterators[currentVertex].hasNext()) {
                int neighbor = adjacentIterators[currentVertex].next();

                if (!visited[neighbor]) {
                    stack.push(neighbor);
                    visited[neighbor] = true;
                    id[neighbor] = count;
                }
            } else {
                stack.pop();
            }
        }
    }

    public boolean connected(int vertex1, int vertex2) {
        return id[vertex1] == id[vertex2];
    }

    public int id(int vertex) {
        return id[vertex];
    }

    public int count() {
        return count;
    }
}
```

#### 总结

| 问 题        | 解决方法          |
| ------------ | ----------------- |
| 单点连通性   | DepthFirstSearch  |
| 单点路径     | DepthFirstPaths   |
| 单点最短路径 | BreadthFirstPaths |
| 连通性       | CC                |
| 检测环       | Cycle             |

### 2.有向图

#### 单点和多点的可达性

```Java
public class DirectedDFS {

    private boolean[] visited;

    public DirectedDFS(Digraph digraph, int source) {
        visited = new boolean[digraph.vertices()];
        dfs(digraph, source);
    }

    public DirectedDFS(Digraph digraph, Iterable<Integer> sources) {
        visited = new boolean[digraph.vertices()];

        for (int source : sources) {
            if (!visited[source]) {
                dfs(digraph, source);
            }
        }
    }

    private void dfs(Digraph digraph, int source) {
        visited[source] = true;

        for (int neighbor : digraph.adjacent(source)) {
            if (!visited[neighbor]) {
                dfs(digraph, neighbor);
            }
        }
    }

    public boolean marked(int vertex) {
        return visited[vertex];
    }

    public static void main(String[] args) {
        Digraph digraph = new Digraph(new In(args[0]));

        Bag<Integer> sources = new Bag<>();
        for (int i = 1; i < args.length; i++) {
            sources.add(Integer.parseInt(args[i]));
        }

        DirectedDFS reachable = new DirectedDFS(digraph, sources);

        for (int vertex = 0; vertex < digraph.vertices(); vertex++) {
            if (reachable.visited[vertex]) {
                StdOut.print(vertex + " ");
            }
        }

        StdOut.println();
    }
}
```

#### 拓扑排序

```Java
public class Topological {

    private Iterable<Integer> topologicalOrder;

    public Topological(Digraph digraph) {
        DirectedCycle cycleFinder = new DirectedCycle(digraph);

        if (!cycleFinder.hasCycle()) {
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(digraph);
            topologicalOrder = depthFirstOrder.reversePostOrder();
        }
    }

    public Iterable<Integer> order() {
        return topologicalOrder;
    }

    public boolean isDAG() {
        return topologicalOrder != null;
    }

    public static void main(String[] args) {
        String filename = args[0];
        String separator = args[1];

        SymbolDigraph symbolDigraph = new SymbolDigraph(filename, separator);
        Topological topological = new Topological(symbolDigraph.digraph());

        for (int vertex : topological.topologicalOrder) {
            StdOut.println(symbolDigraph.name(vertex));
        }
    }
}
```

#### 强连通性

```Java
public class KosarajuSharirSCC {

    private boolean[] visited; // reached vertices
    private int[] id; // component identifiers
    private int count; // number of strong components

    private DigraphInterface digraph;

    public KosarajuSharirSCC(DigraphInterface digraph) {
        visited = new boolean[digraph.vertices()];
        id = new int[digraph.vertices()];
        this.digraph = digraph;

        DepthFirstOrder depthFirstOrder = new DepthFirstOrder(digraph.reverse());

        for (int vertex : depthFirstOrder.reversePostOrder()) {
            if (!visited[vertex]) {
                dfs(digraph, vertex);
                count++;
            }
        }
    }

    private void dfs(DigraphInterface digraph, int vertex) {
        visited[vertex] = true;
        id[vertex] = count;

        for (int neighbor : digraph.adjacent(vertex)) {
            if (!visited[neighbor]) {
                dfs(digraph, neighbor);
            }
        }
    }

    public Digraph getKernelDAG() {
        Digraph kernelDAG = new Digraph(count());

        for (int vertex = 0; vertex < digraph.vertices(); vertex++) {
            for (int neighbor : digraph.adjacent(vertex)) {
                if (id(vertex) != id(neighbor)) {
                    kernelDAG.addEdge(id(vertex), id(neighbor));
                }
            }
        }
        return kernelDAG;
    }

    public boolean stronglyConnected(int vertex1, int vertex2) {
        return id[vertex1] == id[vertex2];
    }

    public int id(int vertex) {
        return id[vertex];
    }

    public int count() {
        return count;
    }
}
```

#### 总结

| 问 题                  | 解决方法                  |
| ---------------------- | ------------------------- |
| 单点和多点的可达性     | DirectedDFS               |
| 单点有向路径           | DepthFirstDirectedPaths   |
| 单点最短有向路径       | BreadthFirstDirectedPaths |
| 有向环检测             | DirectedCycle             |
| 深度优先的顶点排序     | DepthFirstOrder           |
| 优先级限制下的调度问题 | Topological               |
| 拓扑排序               | Topological               |
| 强连通性               | KosarajuSCC               |
| 顶点对的可达性         | TransitiveClosure         |



### 3.最小生成树

加权无向图接口

```Java
public interface EdgeWeightedGraphInterface {

    int vertices();
    int edgesCount();
    void addEdge(Edge edge);
    Iterable<Edge> adjacent(int vertex);
    Iterable<Edge> edges();

}
```

#### 加权无向图

```Java
public class EdgeWeightedGraph implements EdgeWeightedGraphInterface {

    private final int vertices;
    private int edges;
    private Bag<Edge>[] adjacent;

    public EdgeWeightedGraph(int vertices) {
        this.vertices = vertices;
        edges = 0;
        adjacent = (Bag<Edge>[]) new Bag[vertices];

        for (int vertex = 0; vertex < vertices; vertex++) {
            adjacent[vertex] = new Bag<>();
        }
    }

    public EdgeWeightedGraph(In in) {
        this(in.readInt());
        int edges = in.readInt();

        if (edges < 0) {
            throw new IllegalArgumentException("Number of edges must be nonnegative");
        }

        for (int i = 0; i < edges; i++) {
            int vertex1 = in.readInt();
            int vertex2 = in.readInt();
            double weight = in.readDouble();

            Edge edge = new Edge(vertex1, vertex2, weight);
            addEdge(edge);
        }
    }

    public int vertices() {
        return vertices;
    }

    public int edgesCount() {
        return edges;
    }

    public void addEdge(Edge edge) {
        int vertex1 = edge.either();
        int vertex2 = edge.other(vertex1);

        adjacent[vertex1].add(edge);
        adjacent[vertex2].add(edge);
        edges++;
    }

    public Iterable<Edge> adjacent(int vertex) {
        return adjacent[vertex];
    }

    public Iterable<Edge> edges() {
        Bag<Edge> edges = new Bag<>();

        for (int vertex = 0; vertex < vertices; vertex++) {
            for (Edge edge : adjacent[vertex]) {
                if (edge.other(vertex) > vertex) {
                    edges.add(edge);
                }
            }
        }

        return edges;
    }

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();

        for (int vertex = 0; vertex < vertices(); vertex++) {
            stringBuilder.append(vertex).append(": ");

            for (Edge neighbor : adjacent(vertex)) {
                stringBuilder.append(neighbor).append(" ");
            }
            stringBuilder.append("\n");
        }

        return stringBuilder.toString();
    }
}
```

#### Prim算法

```Java
public class PrimMST {

    protected Edge[] edgeTo; // shortest edge from tree vertex
    private double[] distTo; // distTo[vertex] = edgeTo[vertex].weight()
    private boolean[] marked; // true if vertex is on the minimum spanning tree
    private IndexMinPriorityQueue<Double> priorityQueue; // eligible crossing edges

    private double weight;

    public PrimMST(EdgeWeightedGraphInterface edgeWeightedGraph) {
        edgeTo = new Edge[edgeWeightedGraph.vertices()];
        distTo = new double[edgeWeightedGraph.vertices()];
        marked = new boolean[edgeWeightedGraph.vertices()];

        for (int vertex = 0; vertex < edgeWeightedGraph.vertices(); vertex++) {
            distTo[vertex] = Double.POSITIVE_INFINITY;
        }
        priorityQueue = new IndexMinPriorityQueue<>(edgeWeightedGraph.vertices());

        // Initialize priority queue with 0, weight 0
        distTo[0] = 0;
        priorityQueue.insert(0, 0.0);

        while (!priorityQueue.isEmpty()) {
            visit(edgeWeightedGraph, priorityQueue.deleteMin()); // Add closest vertex to the minimum spanning tree
        }
    }

    private void visit(EdgeWeightedGraphInterface edgeWeightedGraph, int vertex) {
        // Add vertex to the minimum spanning tree; update data structures
        marked[vertex] = true;

        for (Edge edge : edgeWeightedGraph.adjacent(vertex)) {
            int otherVertex = edge.other(vertex);
            if (marked[otherVertex]) {
                continue; // vertex-otherVertex is ineligible
            }

            if (edge.weight() < distTo[otherVertex]) {
                // Edge edge is the new best connection from the minimum spanning tree to otherVertex
                if (distTo[otherVertex] != Double.POSITIVE_INFINITY) {
                    weight -= distTo[otherVertex];
                }
                weight += edge.weight();

                edgeTo[otherVertex] = edge;
                distTo[otherVertex] = edge.weight();

                if (priorityQueue.contains(otherVertex)) {
                    priorityQueue.decreaseKey(otherVertex, distTo[otherVertex]);
                } else {
                    priorityQueue.insert(otherVertex, distTo[otherVertex]);
                }
            }
        }
    }

    public Iterable<Edge> edges() {
        Queue<Edge> minimumSpanningTree = new Queue<>();

        for (int vertex = 1; vertex < edgeTo.length; vertex++) {
            minimumSpanningTree.enqueue(edgeTo[vertex]);
        }
        return minimumSpanningTree;
    }

    public double lazyWeight() {
        double weight = 0;

        for (Edge edge : edges()) {
            weight += edge.weight();
        }
        return weight;
    }

    public double eagerWeight() {
        return weight;
    }
}
```

#### Kruskal算法

```
public class KruskalMST {

    private Queue<Edge> minimumSpanningTree;
    private double weight;

    public KruskalMST(EdgeWeightedGraphInterface edgeWeightedGraph) {
        minimumSpanningTree = new Queue<>();
        PriorityQueueResize<Edge> priorityQueue = new PriorityQueueResize<>(PriorityQueueResize.Orientation.MIN);

        for (Edge edge : edgeWeightedGraph.edges()) {
            priorityQueue.insert(edge);
        }

        UnionFind unionFind = new UnionFind(edgeWeightedGraph.vertices());

        while (!priorityQueue.isEmpty() && minimumSpanningTree.size() < edgeWeightedGraph.vertices() - 1) {
            Edge edge = priorityQueue.deleteTop(); // Get lowest-weight edge from priority queue
            int vertex1 = edge.either();
            int vertex2 = edge.other(vertex1);

            // Ignore ineligible edges
            if (unionFind.connected(vertex1, vertex2)) {
                continue;
            }

            unionFind.union(vertex1, vertex2);
            minimumSpanningTree.enqueue(edge); // Add edge to the minimum spanning tree

            weight += edge.weight();
        }
    }

    public Iterable<Edge> edges() {
        return minimumSpanningTree;
    }

    public double lazyWeight() {
        double weight = 0;

        for (Edge edge : edges()) {
            weight += edge.weight();
        }

        return weight;
    }

    public double eagerWeight() {
        return weight;
    }
}
```

#### 总结

| 算法             | 空间 | 时间                     |
| ---------------- | ---- | ------------------------ |
| 延时的 Prim 算法 | *E*  | *E*log*E*                |
| 即时的 Prim 算法 | *V*  | *El*og*V*                |
| Kruskal          | *E*  | *El*og*E*                |
| Fredman-Tarjan   | *V*  | *E*+Vlog*V*              |
| Chazelle         | *V*  | 非常接近但还没有达到 *E* |
| 理想情况         | *V*  | *E*?                     |

Tips: V 个顶点E 条边，最坏情况下的增长数量级

### 4.最短路径

#### 加权有向图

```Java
public class EdgeWeightedDigraph implements EdgeWeightedDigraphInterface {

    private final int vertices;
    private int edges;
    private Bag<DirectedEdge>[] adjacent;

    public EdgeWeightedDigraph(int vertices) {
        this.vertices = vertices;
        edges = 0;
        adjacent = (Bag<DirectedEdge>[]) new Bag[vertices];

        for (int vertex = 0; vertex < vertices; vertex++) {
            adjacent[vertex] = new Bag<>();
        }
    }

    public EdgeWeightedDigraph(In in) {
        this(in.readInt());
        int edges = in.readInt();

        if (edges < 0) {
            throw new IllegalArgumentException("Number of edges must be nonnegative");
        }

        for (int i = 0; i < edges; i++) {
            int vertexFrom = in.readInt();
            int vertexTo = in.readInt();
            double weight = in.readDouble();

            DirectedEdge edge = new DirectedEdge(vertexFrom, vertexTo, weight);
            addEdge(edge);
        }
    }

    public int vertices() {
        return vertices;
    }

    public int edgesCount() {
        return edges;
    }

    public int outdegree(int vertex) {
        return adjacent[vertex].size();
    }

    public void addEdge(DirectedEdge edge) {
        adjacent[edge.from()].add(edge);
        edges++;
    }

    public Iterable<DirectedEdge> adjacent(int vertex) {
        return adjacent[vertex];
    }

    public Iterable<DirectedEdge> edges() {
        Bag<DirectedEdge> bag = new Bag<>();

        for (int vertex = 0; vertex < vertices; vertex++) {
            for (DirectedEdge edge : adjacent[vertex]) {
                bag.add(edge);
            }
        }

        return bag;
    }

    public EdgeWeightedDigraph reverse() {
        EdgeWeightedDigraph reverse = new EdgeWeightedDigraph(vertices);

        for (int vertex = 0; vertex < vertices; vertex++) {
            for (DirectedEdge edge : adjacent(vertex)) {
                int neighbor = edge.to();
                reverse.addEdge(new DirectedEdge(neighbor, vertex, edge.weight()));
            }
        }

        return reverse;
    }

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();

        for (int vertex = 0; vertex < vertices(); vertex++) {
            stringBuilder.append(vertex).append(": ");

            for (DirectedEdge neighbor : adjacent(vertex)) {
                stringBuilder.append(neighbor).append(" ");
            }
            stringBuilder.append("\n");
        }

        return stringBuilder.toString();
    }
}
```

#### Dijkstra算法

```Java
public class DijkstraSP {

    private DirectedEdge[] edgeTo;  // last edge on path to vertex
    private double[] distTo;        // length of path to vertex
    private IndexMinPriorityQueue<Double> priorityQueue;

    public DijkstraSP(EdgeWeightedDigraphInterface edgeWeightedDigraph, int source) {
        edgeTo = new DirectedEdge[edgeWeightedDigraph.vertices()];
        distTo = new double[edgeWeightedDigraph.vertices()];
        priorityQueue = new IndexMinPriorityQueue<>(edgeWeightedDigraph.vertices());

        for (int vertex = 0; vertex < edgeWeightedDigraph.vertices(); vertex++) {
            distTo[vertex] = Double.POSITIVE_INFINITY;
        }
        distTo[source] = 0;
        priorityQueue.insert(source, 0.0);

        while (!priorityQueue.isEmpty()) {
            relax(edgeWeightedDigraph, priorityQueue.deleteMin());
        }
    }

    private void relax(EdgeWeightedDigraphInterface edgeWeightedDigraph, int vertex) {
        for (DirectedEdge edge : edgeWeightedDigraph.adjacent(vertex)) {
            int neighbor = edge.to();

            if (distTo[neighbor] > distTo[vertex] + edge.weight()) {
                distTo[neighbor] = distTo[vertex] + edge.weight();
                edgeTo[neighbor] = edge;

                if (priorityQueue.contains(neighbor)) {
                    priorityQueue.decreaseKey(neighbor, distTo[neighbor]);
                } else {
                    priorityQueue.insert(neighbor, distTo[neighbor]);
                }
            }
        }
    }

    public double distTo(int vertex) {
        return distTo[vertex];
    }

    public DirectedEdge edgeTo(int vertex) {
        return edgeTo[vertex];
    }

    public boolean hasPathTo(int vertex) {
        return distTo[vertex] < Double.POSITIVE_INFINITY;
    }

    public Iterable<DirectedEdge> pathTo(int vertex) {
        if (!hasPathTo(vertex)) {
            return null;
        }

        Stack<DirectedEdge> path = new Stack<>();
        for (DirectedEdge edge = edgeTo[vertex]; edge != null; edge = edgeTo[edge.from()]) {
            path.push(edge);
        }
        return path;
    }
}
```

#### 无环加权有向图的最短路径

```Java
public class AcyclicSP {

    private DirectedEdge[] edgeTo;
    private double[] distTo;

    public AcyclicSP(EdgeWeightedDigraph edgeWeightedDigraph, int source) {
        edgeTo = new DirectedEdge[edgeWeightedDigraph.vertices()];
        distTo = new double[edgeWeightedDigraph.vertices()];

        for (int vertex = 0; vertex < edgeWeightedDigraph.vertices(); vertex++) {
            distTo[vertex] = Double.POSITIVE_INFINITY;
        }

        distTo[source] = 0;

        Topological topological = new Topological(edgeWeightedDigraph);

        for (int vertex : topological.order()) {
            relax(edgeWeightedDigraph, vertex);
        }
    }

    private void relax(EdgeWeightedDigraph edgeWeightedDigraph, int vertex) {

        for (DirectedEdge edge : edgeWeightedDigraph.adjacent(vertex)) {
            int neighbor = edge.to();

            if (distTo[neighbor] > distTo[vertex] + edge.weight()) {
                distTo[neighbor] = distTo[vertex] + edge.weight();
                edgeTo[neighbor] = edge;
            }
        }
    }

    public double distTo(int vertex) {
        return distTo[vertex];
    }

    public boolean hasPathTo(int vertex) {
        return distTo[vertex] < Double.POSITIVE_INFINITY;
    }

    public Iterable<DirectedEdge> pathTo(int vertex) {
        if (!hasPathTo(vertex)) {
            return null;
        }

        Stack<DirectedEdge> path = new Stack<>();
        for (DirectedEdge edge = edgeTo[vertex]; edge != null; edge = edgeTo[edge.from()]) {
            path.push(edge);
        }
        return path;
    }
}
```

#### 基于队列的Bellman-Ford 算法

```Java
public class BellmanFordSP {

    private double[] distTo;               // length of path to vertex
    private DirectedEdge[] edgeTo;         // last edge on path to vertex
    private boolean[] onQueue;             // is this vertex on the queue?
    private Queue<Integer> queue;          // vertices being relaxed
    private int callsToRelax;              // number of calls to relax()
    private Iterable<DirectedEdge> cycle;  // if there is a negative cycle in edgeTo[], return it

    public BellmanFordSP(EdgeWeightedDigraph edgeWeightedDigraph, int source) {
        distTo = new double[edgeWeightedDigraph.vertices()];
        edgeTo = new DirectedEdge[edgeWeightedDigraph.vertices()];
        onQueue = new boolean[edgeWeightedDigraph.vertices()];
        queue = new Queue<>();

        for (int vertex = 0; vertex < edgeWeightedDigraph.vertices(); vertex++) {
            distTo[vertex] = Double.POSITIVE_INFINITY;
        }

        distTo[source] = 0;
        queue.enqueue(source);
        onQueue[source] = true;

        while (!queue.isEmpty() && !hasNegativeCycle()) {
            int vertex = queue.dequeue();
            onQueue[vertex] = false;
            relax(edgeWeightedDigraph, vertex);
        }
    }

    private void relax(EdgeWeightedDigraph edgeWeightedDigraph, int vertex) {

        for (DirectedEdge edge : edgeWeightedDigraph.adjacent(vertex)) {
            int neighbor = edge.to();

            if (distTo[neighbor] > distTo[vertex] + edge.weight()) {
                distTo[neighbor] = distTo[vertex] + edge.weight();
                edgeTo[neighbor] = edge;

                if (!onQueue[neighbor]) {
                    queue.enqueue(neighbor);
                    onQueue[neighbor] = true;
                }
            }

            if (callsToRelax++ % edgeWeightedDigraph.vertices() == 0) {
                findNegativeCycle();
            }
        }
    }

    public double distTo(int vertex) {
        return distTo[vertex];
    }

    public boolean hasPathTo(int vertex) {
        return distTo[vertex] < Double.POSITIVE_INFINITY;
    }

    public Iterable<DirectedEdge> pathTo(int vertex) {
        if (!hasPathTo(vertex)) {
            return null;
        }

        Stack<DirectedEdge> path = new Stack<>();
        for (DirectedEdge edge = edgeTo[vertex]; edge != null; edge = edgeTo[edge.from()]) {
            path.push(edge);
        }

        return path;
    }

    private void findNegativeCycle() {
        int vertices = edgeTo.length;
        EdgeWeightedDigraph shortestPathsTree = new EdgeWeightedDigraph(vertices);

        for (int vertex = 0; vertex < vertices; vertex++) {
            if (edgeTo[vertex] != null) {
                shortestPathsTree.addEdge(edgeTo[vertex]);
            }
        }

        EdgeWeightedDirectedCycle edgeWeightedCycleFinder = new EdgeWeightedDirectedCycle(shortestPathsTree);
        cycle = edgeWeightedCycleFinder.cycle();
    }

    public boolean hasNegativeCycle() {
        return cycle != null;
    }

    public Iterable<DirectedEdge> negativeCycle() {
        return cycle;
    }
}
```

#### 总结

| 算 法                        | 局 限                  | 一般情况  | 最坏情况  | 所需空间 | 优势                     |
| ---------------------------- | ---------------------- | --------- | --------- | -------- | ------------------------ |
| Dijkstra 算法（即时版本）    | 边的权重必须为正       | *E*log*V* | *E*log*V* | *V*      | 最坏情况下仍有较好的性能 |
| 拓扑排序                     | 只适用于无环加权有向图 | *E*+*V*   | *E*+*V*   | *V*      | 是无环图中的最优算法     |
| Bellman-Ford算法（基于队列） | 不能存在负权重环       | *E*+*V*   | *VE*      | *V*      | 适用领域广泛             |

Tips:路径长度的比较次数（增长的数量级）

## 五.字符串

### 1.字符串排序

#### 低位优先的字符串排序

```Java
public class LeastSignificantDigit {

    public static void lsdSort(String[] array, int stringsLength) {

        int alphabetSize = 256; // Extended ASCII characters

        String[] auxArray = new String[array.length];

        for (int digit = stringsLength - 1; digit >= 0; digit--) {
            // Sort by key-indexed counting on digitTh char

            // Compute frequency counts
            int count[] = new int[alphabetSize + 1];
            for (int i = 0; i < array.length; i++) {
                int digitIndex = array[i].charAt(digit);
                count[digitIndex + 1]++;
            }

            // Transform counts to indices
            for (int r = 0; r < alphabetSize; r++) {
                count[r + 1] += count[r];
            }

            // Distribute
            for (int i = 0; i < array.length; i++) {
                int digitIndex = array[i].charAt(digit);
                int indexInAuxArray = count[digitIndex]++;
                auxArray[indexInAuxArray] = array[i];
            }

            // Copy back
            for (int i = 0; i < array.length; i++) {
                array[i] = auxArray[i];
            }
        }
    }
}
```

#### 高位优先字符串排序

```Java
public class MostSignificantDigit {

    private static int alphabetSize = 256; // Extended ASCII characters; radix
    private static final int CUTOFF_FOR_SMALL_SUBARRAYS = 15;
    private static String[] auxArray;

    public static void msdSort(String[] array) {
        auxArray = new String[array.length];
        sort(array, 0, array.length - 1, 0);
    }

    private static void sort(String[] array, int low, int high, int digit) {
        // Sort from array[low] to array[high], starting at the digitTh character
        if (low + CUTOFF_FOR_SMALL_SUBARRAYS >= high) {
            InsertionSort.sort(array, low, high, digit);
            return;
        }

        // Compute frequency counts
        int[] count = new int[alphabetSize + 2];
        for (int i = low; i <= high; i++) {
            int digitIndex = charAt(array[i], digit) + 2;
            count[digitIndex]++;
        }

        // Transform counts to indices
        for (int r = 0; r < alphabetSize + 1; r++) {
            count[r + 1] += count[r];
        }

        // Distribute
        for (int i = low; i <= high; i++) {
            int digitIndex = charAt(array[i], digit) + 1;
            int indexInAuxArray = count[digitIndex]++;
            auxArray[indexInAuxArray] = array[i];
        }

        // Copy back
        for (int i = low; i <= high; i++) {
            array[i] = auxArray[i - low];
        }

        // Recursively sort for each character value
        for (int r = 0; r < alphabetSize; r++) {
            sort(array, low + count[r], low + count[r + 1] - 1,digit + 1);
        }
    }

    private static int charAt(String string, int digit) {
        if (digit < string.length()) {
            return string.charAt(digit);
        } else {
            return -1;
        }
    }

    // Insertion sort for Strings whose first digit characters are equal
    public static class InsertionSort {

        public static void sort(String[] array, int low, int high, int digit) {
            // Sort from array[low] to array[high], starting at the digitTh character
            for (int i = low; i <= high; i++) {
                for (int j = i; j > low && less(array[j], array[j - 1], digit); j--) {
                    ArrayUtil.exchange(array, j, j - 1);
                }
            }
        }

        private static boolean less(String string1, String string2, int digit) {
            for (int i = digit; i < Math.min(string1.length(), string2.length()); i++) {
                if (string1.charAt(i) < string2.charAt(i)) {
                    return true;
                } else if (string1.charAt(i) > string2.charAt(i)) {
                    return false;
                }
            }

            return string1.length() < string2.length();
        }
    }
}
```

#### 三向字符串快速排序

```Java
public class ThreeWayStringQuickSort {

    public static void threeWayStringQuickSort(String[] array) {
        threeWayStringQuickSort(array, 0, array.length - 1, 0);
    }

    private static void threeWayStringQuickSort(String[] array, int low, int high, int digit) {
        if (low >= high) {
            return;
        }

        int lowerThan = low;
        int greaterThan = high;

        int pivot = charAt(array[low], digit);

        int index = low + 1;

        while (index <= greaterThan) {
            int currentChar = charAt(array[index], digit);

            if (currentChar < pivot) {
                ArrayUtil.exchange(array, lowerThan++, index++);
            } else if (currentChar > pivot) {
                ArrayUtil.exchange(array, index, greaterThan--);
            } else {
                index++;
            }
        }

        // Now array[low..lowerThan - 1] < pivot = array[lowerThan..greaterThan] < array[greaterThan + 1..high]
        threeWayStringQuickSort(array, low, lowerThan - 1, digit);
        if (pivot >= 0) {
            threeWayStringQuickSort(array, lowerThan, greaterThan, digit + 1);
        }
        threeWayStringQuickSort(array, greaterThan + 1, high, digit);
    }

    private static int charAt(String string, int digit) {
        if (digit < string.length()) {
            return string.charAt(digit);
        } else {
            return -1;
        }
    }

}
```

#### 总结

| 算法                 | 是否稳定 | 原地排序 |       运行时间        |  额外空间  | 优势领域                                           |
| -------------------- | :------: | :------: | :-------------------: | :--------: | -------------------------------------------------- |
| 字符串的插入排序     |    是    |    是    |   *N* 到 *N*2 之间    |     1      | 小数组或是已经有序的数组                           |
| 快速排序             |    否    |    是    |      *N*log2*N*       |   log*N*   | 通用排序算法，特别适合用于空间不足的情况           |
| 归并排序             |    是    |    否    |      *N*log2*N*       |    *N*     | 稳定的通用排序算法                                 |
| 三向快速排序         |    否    |    是    | *N* 到 *N*log*N* 之间 |   log*N*   | 大量重复键                                         |
| 低位优先的字符串排序 |    是    |    否    |         *NW*          |    *N*     | 较短的定长字符串                                   |
| 高位优先的字符串排序 |    是    |    否    |   *N* 到 *Nw* 之间    |  *N*+*WR*  | 随机字符串                                         |
| 三向字符串快速排序   |    否    |    是    |   *N* 到 *Nw* 之间    | *W*+log*N* | 通用排序算法，特别适合用于含有较长公共前缀的字符串 |

 Tips:在将基于大小为 *R* 的字母表的 *N* 个字符串排序的过程中调用 charAt() 方法次数的增长数量级（平均长度为 *w*，最

大长度为 *W*）



### 2.单词查找树

词查找树接口

```java
public interface TrieInterface<Value> {

    int size();
    boolean isEmpty();
    boolean contains(String key);
    Value get(String key);
    void put(String key, Value value);
    void delete(String key);

    Iterable<String> keys();
    Iterable<String> keysWithPrefix(String prefix);
    Iterable<String> keysThatMatch(String pattern);
    String longestPrefixOf(String query);

}
```

#### 基于单词查找树的符号表

```Java
public class Trie<Value> implements TrieInterface<Value> {

    protected static final int R = 256; // radix
    protected Node root = new Node();

    protected static class Node {
        protected Object value;
        protected Node[] next = new Node[R];
        protected int size;
    }

    public int size() {
        return size(root);
    }

    protected int size(Node node) {
        if (node == null) {
            return 0;
        }

        return node.size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public boolean contains(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        return get(key) != null;
    }

    public Value get(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (key.length() == 0) {
            throw new IllegalArgumentException("Key must have a positive length");
        }

        Node node = get(root, key, 0);

        if (node == null) {
            return null;
        }
        return (Value) node.value;
    }

    private Node get(Node node, String key, int digit) {
        if (node == null) {
            return null;
        }

        if (digit == key.length()) {
            return node;
        }

        char nextChar = key.charAt(digit); // Use digitTh key char to identify subtrie.
        return get(node.next[nextChar], key, digit + 1);
    }

    public void put(String key, Value value) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (value == null) {
            delete(key);
            return;
        }

        boolean isNewKey = false;

        if (!contains(key)) {
            isNewKey = true;
        }

        root = put(root, key, value, 0, isNewKey);
    }

    private Node put(Node node, String key, Value value, int digit, boolean isNewKey) {
        if (node == null) {
            node = new Node();
        }

        if (isNewKey) {
            node.size = node.size + 1;
        }

        if (digit == key.length()) {
            node.value = value;
            return node;
        }

        char nextChar = key.charAt(digit); // Use digitTh key char to identify subtrie.
        node.next[nextChar] = put(node.next[nextChar], key, value, digit + 1, isNewKey);

        return node;
    }

    public Iterable<String> keys() {
        return keysWithPrefix("");
    }

    public Iterable<String> keysWithPrefix(String prefix) {
        if (prefix == null) {
            throw new IllegalArgumentException("Prefix cannot be null");
        }

        Queue<String> keysWithPrefix = new Queue<>();
        Node nodeWithPrefix = get(root, prefix, 0);
        collect(nodeWithPrefix, new StringBuilder(prefix), keysWithPrefix);

        return keysWithPrefix;
    }

    private void collect(Node node, StringBuilder prefix, Queue<String> queue) {
        if (node == null) {
            return;
        }

        if (node.value != null) {
            queue.enqueue(prefix.toString());
        }

        for (char nextChar = 0; nextChar < R; nextChar++) {
            prefix.append(nextChar);
            collect(node.next[nextChar], prefix, queue);
            prefix.deleteCharAt(prefix.length() - 1);
        }
    }

    public Iterable<String> keysThatMatch(String pattern) {
        if (pattern == null) {
            throw new IllegalArgumentException("Pattern cannot be null");
        }

        Queue<String> keysThatMatch = new Queue<>();
        collect(root, new StringBuilder(), pattern, keysThatMatch);
        return keysThatMatch;
    }

    private void collect(Node node, StringBuilder prefix, String pattern, Queue<String> queue) {
        if (node == null) {
            return;
        }

        int digit = prefix.length();
        if (digit == pattern.length() && node.value != null) {
            queue.enqueue(prefix.toString());
        }

        if (digit == pattern.length()) {
            return;
        }

        char nextCharInPattern = pattern.charAt(digit);

        for (char nextChar = 0; nextChar < R; nextChar++) {
            if (nextCharInPattern == '.' || nextCharInPattern == nextChar) {
                prefix.append(nextChar);
                collect(node.next[nextChar], prefix, pattern, queue);
                prefix.deleteCharAt(prefix.length() - 1);
            }
        }
    }

    public String longestPrefixOf(String query) {
        if (query == null) {
            throw new IllegalArgumentException("Query cannot be null");
        }

        int length = search(root, query, 0, 0);
        return query.substring(0, length);
    }

    private int search(Node node, String query, int digit, int length) {
        if (node == null) {
            return length;
        }

        if (node.value != null) {
            length = digit;
        }

        if (digit == query.length()) {
            return length;
        }

        char nextChar = query.charAt(digit);
        return search(node.next[nextChar], query, digit + 1, length);
    }

    public void delete(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (!contains(key)) {
            return;
        }

        root = delete(root, key, 0);
    }

    private Node delete(Node node, String key, int digit) {
        if (node == null) {
            return null;
        }

        node.size = node.size - 1;

        if (digit == key.length()) {
            node.value = null;
        } else {
            char nextChar = key.charAt(digit);
            node.next[nextChar] = delete(node.next[nextChar], key, digit + 1);
        }

        if (node.value != null) {
            return node;
        }

        for (char nextChar = 0; nextChar < R; nextChar++) {
            if (node.next[nextChar] != null) {
                return node;
            }
        }

        return null;
    }

    // Ordered methods

    // Returns the highest key in the symbol table smaller than or equal to key.
    public String floor(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        return floor(root, key, 0, new StringBuilder(), null, true);
    }

    private String floor(Node node, String key, int digit, StringBuilder prefix, String lastKeyFound,
                         boolean mustBeEqualDigit) {
        if (node == null) {
            return null;
        }

        if (prefix.toString().compareTo(key) > 0) {
            return lastKeyFound;
        }

        if (node.value != null) {
            lastKeyFound = prefix.toString();
        }

        char currentChar;

        if (mustBeEqualDigit && digit < key.length()) {
            currentChar = key.charAt(digit);
        } else {
            currentChar = R - 1;
        }

        for (char nextChar = currentChar; true; nextChar--) {
            if (node.next[nextChar] != null) {
                if (nextChar < currentChar) {
                    mustBeEqualDigit = false;
                }

                lastKeyFound = floor(node.next[nextChar], key, digit + 1, prefix.append(nextChar), lastKeyFound, mustBeEqualDigit);

                if (lastKeyFound != null) {
                    return lastKeyFound;
                }
                prefix.deleteCharAt(prefix.length() - 1);
            }

            // nextChar value never becomes less than zero in the for loop, so we need this extra validation
            if (nextChar == 0) {
                break;
            }
        }

        return lastKeyFound;
    }

    // Returns the smallest key in the symbol table greater than or equal to key.
    public String ceiling(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        return ceiling(root, key, 0, new StringBuilder(), true);
    }

    private String ceiling(Node node, String key, int digit, StringBuilder prefix, boolean mustBeEqualDigit) {
        if (node == null) {
            return null;
        }

        if (node.value != null && prefix.toString().compareTo(key) >= 0) {
            return prefix.toString();
        }

        char currentChar;

        if (mustBeEqualDigit && digit < key.length()) {
            currentChar = key.charAt(digit);
        } else {
            currentChar = 0;
        }

        for (char nextChar = currentChar; nextChar < R; nextChar++) {
            if (node.next[nextChar] != null) {
                if (nextChar > currentChar) {
                    mustBeEqualDigit = false;
                }

                String keyFound = ceiling(node.next[nextChar], key, digit + 1, prefix.append(nextChar),
                        mustBeEqualDigit);

                if (keyFound != null) {
                    return keyFound;
                }
                prefix.deleteCharAt(prefix.length() - 1);
            }
        }

        return null;
    }

    public String select(int index) {
        if (index < 0 || index >= size()) {
            throw new IllegalArgumentException("Index cannot be negative and must be lower than trie size");
        }

        return select(root, index, new StringBuilder());
    }

    private String select(Node node, int index, StringBuilder prefix) {
        if (node == null) {
            return null;
        }

        if (node.value != null) {
            index--;

            // Found the key with the target index
            if (index == -1) {
                return prefix.toString();
            }
        }

        for (char nextChar = 0; nextChar < R; nextChar++) {
            if (node.next[nextChar] != null) {
                if (index - size(node.next[nextChar]) < 0) {
                    return select(node.next[nextChar], index, prefix.append(nextChar));
                } else {
                    index = index - size(node.next[nextChar]);
                }
            }
        }

        return null;
    }

    public int rank(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        return rank(root, key, 0, 0);
    }

    private int rank(Node node, String key, int digit, int size) {
        if (node == null || digit == key.length()) {
            return size;
        }

        // If a prefix key was found, add 1 to rank
        if (node.value != null) {
            if (digit < key.length()) {
                size++;
            } else {
                return size;
            }
        }

        char currentChar = key.charAt(digit);

        for (char nextChar = 0; nextChar < currentChar; nextChar++) {
            size += size(node.next[nextChar]);
        }

        return rank(node.next[currentChar], key, digit + 1, size);
    }

    public String min() {
        if (isEmpty()) {
            return null;
        }

        return min(root, new StringBuilder());
    }

    private String min(Node node, StringBuilder prefix) {

        if (node.value != null) {
            return prefix.toString();
        }

        for (char nextChar = 0; nextChar < R; nextChar++) {
            if (node.next[nextChar] != null) {
                return min(node.next[nextChar], prefix.append(nextChar));
            }
        }

        return prefix.toString();
    }

    public String max() {
        if (isEmpty()) {
            return null;
        }

        return max(root, new StringBuilder());
    }

    private String max(Node node, StringBuilder prefix) {

        for (char nextChar = R - 1; true; nextChar--) {
            if (node.next[nextChar] != null) {
                return max(node.next[nextChar], prefix.append(nextChar));
            }

            // nextChar value never becomes less than zero in the for loop, so we need this extra validation
            if (nextChar == 0) {
                break;
            }
        }

        return prefix.toString();
    }

    public void deleteMin() {
        if (isEmpty()) {
            return;
        }

        String minKey = min();
        delete(minKey);
    }

    public void deleteMax() {
        if (isEmpty()) {
            return;
        }

        String maxKey = max();
        delete(maxKey);
    }

}
```

#### 三向单词查找树

```Java
public class TernarySearchTrie<Value> implements TrieInterface<Value> {

    private int size;
    protected Node root;

    protected class Node {
        char character;
        Value value;
        int size;

        Node left;
        Node middle;
        Node right;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size() == 0;
    }

    public boolean contains(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        return get(key) != null;
    }

    public Value get(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (key.length() == 0) {
            throw new IllegalArgumentException("Key must have a positive length");
        }

        Node node = get(root, key, 0);

        if (node == null) {
            return null;
        }
        return node.value;
    }

    protected Node get(Node node, String key, int digit) {
        if (node == null) {
            return null;
        }

        char currentChar = key.charAt(digit);

        if (currentChar < node.character) {
            return get(node.left, key, digit);
        } else if (currentChar > node.character) {
            return get(node.right, key, digit);
        } else if (digit < key.length() - 1) {
            return get(node.middle, key, digit + 1);
        } else {
            return node;
        }
    }

    public void put(String key, Value value) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (value == null) {
            delete(key);
            return;
        }

        boolean isNewKey = false;

        if (!contains(key)) {
            isNewKey = true;
        }

        root = put(root, key, value, 0, isNewKey);
    }

    private Node put(Node node, String key, Value value, int digit, boolean isNewKey) {
        char currentChar = key.charAt(digit);

        if (node == null) {
            node = new Node();
            node.character = currentChar;
        }

        if (currentChar < node.character) {
            node.left = put(node.left, key, value, digit, isNewKey);
        } else if (currentChar > node.character) {
            node.right = put(node.right, key, value, digit, isNewKey);
        } else if (digit < key.length() - 1) {
            node.middle = put(node.middle, key, value, digit + 1, isNewKey);

            if (isNewKey) {
                node.size = node.size + 1;
            }
        } else {
            node.value = value;

            if (isNewKey) {
                node.size = node.size + 1;
                size++;
            }
        }

        return node;
    }

    public void delete(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        if (!contains(key)) {
            return;
        }

        root = delete(root, key, 0);
        size--;
    }

    private Node delete(Node node, String key, int digit) {
        if (node == null) {
            return null;
        }

        if (digit == key.length() - 1) {
            node.size = node.size - 1;
            node.value = null;
        } else {
            char nextChar = key.charAt(digit);

            if (nextChar < node.character) {
                node.left = delete(node.left, key, digit);
            } else if (nextChar > node.character) {
                node.right = delete(node.right, key, digit);
            } else {
                node.size = node.size - 1;
                node.middle = delete(node.middle, key, digit + 1);
            }
        }

        if (node.size == 0) {
            if (node.left == null && node.right == null) {
                return null;
            } else if (node.left == null) {
                return node.right;
            } else if (node.right == null) {
                return node.left;
            } else {
                Node aux = node;
                node = min(aux.right);
                node.right = deleteMin(aux.right);
                node.left = aux.left;
            }
        }

        return node;
    }

    public Iterable<String> keys() {
        Queue<String> keys = new Queue<>();
        collect(root, new StringBuilder(), keys);
        return keys;
    }

    public Iterable<String> keysWithPrefix(String prefix) {
        if (prefix == null) {
            throw new IllegalArgumentException("Prefix cannot be null");
        }

        Queue<String> keysWithPrefix = new Queue<>();

        Node nodeWithPrefix = get(root, prefix, 0);

        if (nodeWithPrefix == null) {
            return keysWithPrefix;
        }

        if (nodeWithPrefix.value != null) {
            keysWithPrefix.enqueue(prefix);
        }

        collect(nodeWithPrefix.middle, new StringBuilder(prefix), keysWithPrefix);
        return keysWithPrefix;
    }

    private void collect(Node node, StringBuilder prefix, Queue<String> queue) {
        if (node == null) {
            return;
        }

        collect(node.left, prefix, queue);

        if (node.value != null) {
            queue.enqueue(prefix.toString() + node.character);
        }

        collect(node.middle, prefix.append(node.character), queue);
        prefix.deleteCharAt(prefix.length() - 1);
        collect(node.right, prefix, queue);
    }

    public Iterable<String> keysThatMatch(String pattern) {
        if (pattern == null) {
            throw new IllegalArgumentException("Pattern cannot be null");
        }

        Queue<String> keysThatMatch = new Queue<>();
        collect(root, new StringBuilder(), pattern, keysThatMatch);
        return keysThatMatch;
    }

    private void collect(Node node, StringBuilder prefix, String pattern, Queue<String> queue) {
        if (node == null) {
            return;
        }

        int digit = prefix.length();
        char nextCharInPattern = pattern.charAt(digit);

        if (nextCharInPattern == '.' || nextCharInPattern < node.character) {
            collect(node.left, prefix, pattern, queue);
        }
        if (nextCharInPattern == '.' || nextCharInPattern == node.character) {
            if (digit == pattern.length() - 1 && node.value != null) {
                queue.enqueue(prefix.toString() + node.character);
            } else if (digit < pattern.length() - 1) {
                collect(node.middle, prefix.append(node.character), pattern, queue);
                prefix.deleteCharAt(prefix.length() - 1);
            }
        }
        if (nextCharInPattern == '.' || nextCharInPattern > node.character) {
            collect(node.right, prefix, pattern, queue);
        }
    }

    public String longestPrefixOf(String query) {
        if (query == null) {
            throw new IllegalArgumentException("Query cannot be null");
        }

        int length = search(root, query, 0, 0);
        return query.substring(0, length);
    }

    private int search(Node node, String query, int digit, int length) {
        if (node == null) {
            return length;
        }

        if (node.value != null) {
            length = digit + 1;
        }

        char nextChar = query.charAt(digit);

        if (nextChar < node.character) {
            return search(node.left, query, digit, length);
        } else if (nextChar > node.character) {
            return search(node.right, query, digit, length);
        } else if (digit < query.length() - 1) {
            return search(node.middle, query, digit + 1, length);
        } else {
            return length;
        }
    }

    // Ordered methods

    // Returns the highest key in the symbol table smaller than or equal to key.
    public String floor(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        return floor(root, key, 0, new StringBuilder(), null, true);
    }

    private String floor(Node node, String key, int digit, StringBuilder prefix, String lastKeyFound,
                         boolean mustBeEqualDigit) {
        if (node == null) {
            return lastKeyFound;
        }

        StringBuilder prefixWithCharacter = new StringBuilder(prefix).append(node.character);

        char currentChar;
        if (digit < key.length() && mustBeEqualDigit) {
            currentChar = key.charAt(digit);
        } else {
            currentChar = Character.MAX_VALUE;
            mustBeEqualDigit = false;
        }

        if (currentChar < node.character && mustBeEqualDigit) {
            return floor(node.left, key, digit, prefix, lastKeyFound, true);
        } else if (!mustBeEqualDigit || currentChar >= node.character) {
            // Optimization: if current prefix is higher than the search key, left is the only way to go
            if (prefixWithCharacter.toString().compareTo(key) > 0) {

                if (node.left != null) {
                    return floor(node.left, key, digit, prefix, lastKeyFound, mustBeEqualDigit);
                }
                return lastKeyFound;
            }

            if (mustBeEqualDigit && currentChar > node.character) {
                mustBeEqualDigit = false;
            }

            // Check child nodes in the order: right, middle, current, left
            String rightKey = floor(node.right, key, digit, prefix, lastKeyFound, mustBeEqualDigit);
            if (rightKey != null) {
                return rightKey;
            }

            String middleKey = floor(node.middle, key, digit + 1, prefixWithCharacter, null, mustBeEqualDigit);
            if (middleKey != null) {
                return middleKey;
            }

            if (node.value != null && prefixWithCharacter.toString().compareTo(key) <= 0) {
                return prefixWithCharacter.toString();
            }

            String leftKey = floor(node.left, key, digit, prefix, lastKeyFound, mustBeEqualDigit);
            if (leftKey != null) {
                return leftKey;
            }
        }

        return null;
    }

    // Returns the smallest key in the symbol table greater than or equal to key.
    public String ceiling(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        return ceiling(root, key, 0, new StringBuilder(), null, true);
    }

    private String ceiling(Node node, String key, int digit, StringBuilder prefix, String lastKeyFound,
                           boolean mustBeEqualDigit) {
        if (node == null) {
            return lastKeyFound;
        }

        StringBuilder prefixWithCharacter = new StringBuilder(prefix).append(node.character);

        char currentChar;
        if (digit < key.length() && mustBeEqualDigit) {
            currentChar = key.charAt(digit);
        } else {
            currentChar = 0;
            mustBeEqualDigit = false;
        }

        if (currentChar > node.character && mustBeEqualDigit) {
            return ceiling(node.right, key, digit, prefix, lastKeyFound, true);
        } else if (!mustBeEqualDigit || currentChar <= node.character) {
            if (mustBeEqualDigit && currentChar < node.character) {
                mustBeEqualDigit = false;
            }

            // Check child nodes in the order: left, current, middle, right
            if (!mustBeEqualDigit) {
                lastKeyFound = ceiling(node.left, key, digit, prefix, null, false);
                if (lastKeyFound != null) {
                    return lastKeyFound;
                }
            }

            if (node.value != null && prefixWithCharacter.toString().compareTo(key) >= 0) {
                return prefixWithCharacter.toString();
            }

            String middleKey = ceiling(node.middle, key, digit + 1, prefixWithCharacter, null, mustBeEqualDigit);
            if (middleKey != null) {
                return middleKey;
            }

            String rightKey = ceiling(node.right, key, digit, prefix, null, mustBeEqualDigit);
            if (rightKey != null) {
                return rightKey;
            }
        }

        return null;
    }

    public String select(int index) {
        if (index < 0 || index >= size()) {
            throw new IllegalArgumentException("Index cannot be negative and must be lower than TST size");
        }

        return select(root, index, new StringBuilder());
    }

    private String select(Node node, int index, StringBuilder prefix) {
        if (node == null) {
            return null;
        }

        int leftSubtreeSize = getTreeSize(node.left);
        int tstSize = leftSubtreeSize + node.size;

        if (index < leftSubtreeSize) {
            return select(node.left, index, prefix);
        } else if (index >= tstSize) {
            return select(node.right, index - tstSize, prefix);
        } else {
            index = index - leftSubtreeSize;

            if (node.value != null) {
                if (index == 0) {
                    return prefix.append(node.character).toString();
                }
                index--;
            }

            prefix.append(node.character);
            return select(node.middle, index, prefix);
        }
    }

    public int rank(String key) {
        if (key == null) {
            throw new IllegalArgumentException("Key cannot be null");
        }

        return rank(root, key, 0, 0);
    }

    private int rank(Node node, String key, int digit, int size) {
        if (node == null) {
            return size;
        }

        char currentChar = key.charAt(digit);

        if (currentChar < node.character) {
            return rank(node.left, key, digit, size);
        } else {
            if (currentChar > node.character) {
                if (node.value != null) {
                    size++;
                }

                return getTreeSize(node.left) + getTreeSize(node.middle) + rank(node.right, key, digit, size);
            } else if (digit < key.length() - 1) {
                // Is current key a prefix of the search key?
                if (digit < key.length() - 1 && node.value != null) {
                    size++;
                }

                return getTreeSize(node.left) + rank(node.middle, key, digit + 1, size);
            } else {
                return getTreeSize(node.left) + size;
            }
        }
    }

    private int getTreeSize(Node node) {
        if (node == null) {
            return 0;
        }

        int size = node.size;
        size += getTreeSize(node.left);
        size += getTreeSize(node.right);

        return size;
    }

    public String min() {
        if (isEmpty()) {
            return null;
        }

        Node minNode = min(root);

        StringBuilder minKey = new StringBuilder();
        minKey.append(minNode.character);

        while (minNode.value == null) {
            minNode = minNode.middle;

            while (minNode.left != null) {
                minNode = minNode.left;
            }
            minKey.append(minNode.character);
        }

        return minKey.toString();
    }

    private Node min(Node node) {
        if (node.left == null) {
            return node;
        }

        return min(node.left);
    }

    public String max() {
        if (isEmpty()) {
            return null;
        }

        Node maxNode = max(root);

        StringBuilder maxKey = new StringBuilder();
        maxKey.append(maxNode.character);

        // Verify if size is different than 1 to avoid getting max key prefixes instead of the max key
        while (maxNode.size != 1 || maxNode.value == null) {
            maxNode = maxNode.middle;

            while (maxNode.right != null) {
                maxNode = maxNode.right;
            }
            maxKey.append(maxNode.character);
        }

        return maxKey.toString();
    }

    private Node max(Node node) {
        if (node.right == null) {
            return node;
        }

        return max(node.right);
    }

    public void deleteMin() {
        if (isEmpty()) {
            return;
        }

        String minKey = min();
        delete(minKey);
    }

    // Used only in delete()
    private Node deleteMin(Node node) {
        if (node.left == null) {
            return node.right;
        }

        node.left = deleteMin(node.left);
        return node;
    }

    public void deleteMax() {
        if (isEmpty()) {
            return;
        }

        String maxKey = max();
        delete(maxKey);
    }
}
```

#### 总结

如果空间足够，R向单词查找树的速度是最快的，能够在常数次字符比较内完成查找。

对于大型字母表，R 向单词查找树所需的空间可能无法满足时，三向单词查找树是最佳的选择，因为它对“字符”比较次数是对数级别的比较，而二叉查找树中键的比较次数是对数级别的。

### 3.子字符串查找

子字符串查找接口

```Java
public interface SubstringSearch {

    int BRUTEFORCE = 0;
    int KNUTH_MORRIS_PRATT = 1;
    int BOYER_MOORE = 2;
    int RABIN_KARP = 3;

    String BRUTEFORCE_METHOD = "Bruteforce";
    String KNUTH_MORRIS_PRATT_METHOD = "Knuth-Morris-Pratt";
    String BOYER_MOORE_METHOD = "Boyer-Moore";
    String RABIN_KARP_METHOD = "Rabin-Karp";

    int search(String text);
    int count(String text);
    Iterable<Integer> findAll(String text);

}
```

#### KMP算法

```java
public class KnuthMorrisPratt implements SubstringSearch {

    protected String pattern;
    protected int[][] dfa;  // deterministic-finite-automaton

    public KnuthMorrisPratt(String pattern) {
        if (pattern == null || pattern.length() == 0) {
            throw new IllegalArgumentException("Invalid pattern");
        }

        // Build DFA from pattern
        this.pattern = pattern;

        int patternLength = pattern.length();
        int alphabetSize = 256;

        dfa = new int[alphabetSize][patternLength];
        dfa[pattern.charAt(0)][0] = 1;

        int restartState = 0;

        for (int patternIndex = 1; patternIndex < patternLength; patternIndex++) {
            // Compute dfa[][patternIndex]
            for (int currentChar = 0; currentChar < alphabetSize; currentChar++) {
                dfa[currentChar][patternIndex] = dfa[currentChar][restartState]; // Copy mismatch cases
            }
            dfa[pattern.charAt(patternIndex)][patternIndex] = patternIndex + 1;  // Set match case
            restartState = dfa[pattern.charAt(patternIndex)][restartState];      // Update restart state
        }
    }

    // Search for pattern in text.
    // Returns the index of the first occurrence of the pattern string in the text string or textLength if no such match.
    public int search(String text) {
        int textIndex;
        int patternIndex;
        int textLength = text.length();
        int patternLength = pattern.length();

        for (textIndex = 0, patternIndex = 0; textIndex < textLength && patternIndex < patternLength; textIndex++) {
            patternIndex = dfa[text.charAt(textIndex)][patternIndex];
        }
        if (patternIndex == patternLength) {
            return textIndex - patternLength; // found
        } else {
            return textLength;                // not found
        }
    }

    // Count the occurrences of pattern in the text
    public int count(String text) {
        int count = 0;

        int occurrenceIndex = searchFromIndex(text, 0);

        while (occurrenceIndex != text.length()) {
            count++;
            occurrenceIndex = searchFromIndex(text, occurrenceIndex + 1);
        }

        return count;
    }

    // Finds all the occurrences of pattern in the text
    public Iterable<Integer> findAll(String text) {
        Queue<Integer> offsets = new Queue<>();

        int occurrenceIndex = searchFromIndex(text, 0);

        while (occurrenceIndex != text.length()) {
            offsets.enqueue(occurrenceIndex);
            occurrenceIndex = searchFromIndex(text, occurrenceIndex + 1);
        }

        return offsets;
    }

    // Searches for the pattern in the text starting at specified index.
    // Most of the code is copied from search() method instead of making search() call this method with textStartIndex 0
    // in order to keep the methods separated for educational purposes.
    protected int searchFromIndex(String text, int textStartIndex) {
        int textIndex;
        int patternIndex;
        int textLength = text.length();
        int patternLength = pattern.length();

        for (textIndex = textStartIndex, patternIndex = 0; textIndex < textLength && patternIndex < patternLength;
             textIndex++) {
            patternIndex = dfa[text.charAt(textIndex)][patternIndex];
        }
        if (patternIndex == patternLength) {
            return textIndex - patternLength; // found
        } else {
            return textLength;                // not found
        }
    }

    // Parameters example: AACAA AABRAACADABRAACAADABRA
    public static void main(String[] args) {
        String pattern = args[0];
        String text = args[1];

        KnuthMorrisPratt knuthMorrisPratt = new KnuthMorrisPratt(pattern);
        StdOut.println("text:    " + text);

        int offset = knuthMorrisPratt.search(text);
        StdOut.print("pattern: ");
        for (int i = 0; i < offset; i++) {
            StdOut.print(" ");
        }
        StdOut.println(pattern);
    }

}
```

#### Boyer-Moore算法

```
public class BoyerMoore implements SubstringSearch {

    protected int[] right;
    protected String pattern;

    public BoyerMoore(String pattern) {
        if (pattern == null) {
            throw new IllegalArgumentException("Invalid pattern");
        }

        this.pattern = pattern;
        int alphabetSize = 256;

        right = new int[alphabetSize];

        for (int currentChar = 0; currentChar < alphabetSize; currentChar++) {
            right[currentChar] = -1; // -1 for chars not in pattern
        }

        for (int patternIndex = 0; patternIndex < pattern.length(); patternIndex++)  {
            right[pattern.charAt(patternIndex)] = patternIndex; // rightmost position for chars in pattern
        }
    }

    // Search for pattern in the text.
    // Returns the index of the first occurrence of the pattern string in the text string or textLength if no such match.
    public int search(String text) {
        int textLength = text.length();
        int patternLength = pattern.length();

        int skip;

        for (int textIndex = 0; textIndex <= textLength - patternLength; textIndex += skip) {
            // Does the pattern match the text at position textIndex?
            skip = 0;

            for (int patternIndex = patternLength - 1; patternIndex >= 0; patternIndex--) {
                if (pattern.charAt(patternIndex) != text.charAt(textIndex + patternIndex)) {
                    skip = Math.max(1, patternIndex - right[text.charAt(textIndex + patternIndex)]);
                    break;
                }
            }
            if (skip == 0) {
                return textIndex; // found
            }
        }

        return textLength;        // not found
    }

    // Count the occurrences of pattern in the text
    public int count(String text) {
        int count = 0;

        int occurrenceIndex = searchFromIndex(text, 0);

        while (occurrenceIndex != text.length()) {
            count++;
            occurrenceIndex = searchFromIndex(text, occurrenceIndex + 1);
        }

        return count;
    }

    // Finds all the occurrences of pattern in the text
    public Iterable<Integer> findAll(String text) {
        Queue<Integer> offsets = new Queue<>();

        int occurrenceIndex = searchFromIndex(text, 0);

        while (occurrenceIndex != text.length()) {
            offsets.enqueue(occurrenceIndex);
            occurrenceIndex = searchFromIndex(text, occurrenceIndex + 1);
        }

        return offsets;
    }

    // Searches for the pattern in the text starting at specified index.
    // Most of the code is copied from search() method instead of making search() call this method with textStartIndex 0
    // in order to keep the methods separated for educational purposes.
    protected int searchFromIndex(String text, int textStartIndex) {
        int textLength = text.length();
        int patternLength = pattern.length();

        int skip;

        for (int textIndex = textStartIndex; textIndex <= textLength - patternLength; textIndex += skip) {
            // Does the pattern match the text at position textIndex?
            skip = 0;

            for (int patternIndex = patternLength - 1; patternIndex >= 0; patternIndex--) {
                if (pattern.charAt(patternIndex) != text.charAt(textIndex + patternIndex)) {
                    skip = Math.max(1, patternIndex - right[text.charAt(textIndex + patternIndex)]);
                    break;
                }
            }
            if (skip == 0) {
                return textIndex; // found
            }
        }

        return textLength;        // not found
    }

    // Parameters example: AACAA AABRAACADABRAACAADABRA
    public static void main(String[] args) {
        String pattern = args[0];
        String text = args[1];

        BoyerMoore boyerMoore = new BoyerMoore(pattern);
        StdOut.println("text:    " + text);

        int offset = boyerMoore.search(text);
        StdOut.print("pattern: ");
        for (int i = 0; i < offset; i++) {
            StdOut.print(" ");
        }
        StdOut.println(pattern);
    }

}
```

#### Rabin-Karp算法

```
public class RabinKarp implements SubstringSearch {

    protected String pattern;        // Only needed in the Las Vegas version
    protected long patternHash;
    protected int patternLength;
    protected long largePrimeNumber; // a large prime, small enough to avoid long overflow
    protected int alphabetSize = 256;
    protected long rm;               // rm = alphabetSize^(patternLength - 1) % largePrimeNumber
    private boolean isMonteCarloVersion;

    public RabinKarp(String pattern, boolean isMonteCarloVersion) {

        if (pattern == null) {
            throw new IllegalArgumentException("Invalid pattern");
        }

        this.pattern = pattern;
        patternLength = pattern.length();
        this.isMonteCarloVersion = isMonteCarloVersion;

        largePrimeNumber = longRandomPrime();

        rm = 1;
        for (int patternIndex = 1; patternIndex <= patternLength - 1; patternIndex++) {
            rm = (rm * alphabetSize) % largePrimeNumber;  // Compute alphabetSize^(patternLength - 1) % largePrimeNumber
        }                                                 // for use in removing leading digit.

        patternHash = hash(pattern);
    }

    // A random 31-bit prime
    protected long longRandomPrime() {
        BigInteger prime = BigInteger.probablePrime(31, new Random());
        return prime.longValue();
    }

    protected boolean check(String text, int textIndex) {
        if (isMonteCarloVersion) {
            return true;
        }

        // Las Vegas version
        for (int patternIndex = 0; patternIndex < patternLength; patternIndex++) {
            if (pattern.charAt(patternIndex) != text.charAt(textIndex + patternIndex)) {
                return false;
            }
        }

        return true;
    }

    // Horner's method applied to modular hashing
    protected long hash(String key) {
        // Compute hash for key[0..patternLength - 1]
        long hash = 0;

        for (int patternIndex = 0; patternIndex < patternLength; patternIndex++) {
            hash = (hash * alphabetSize + key.charAt(patternIndex)) % largePrimeNumber;
        }

        return hash;
    }

    // Search for a hash match in the text.
    // Returns the index of the first occurrence of the pattern string in the text string or textLength if no such match.
    public int search(String text) {
        int textLength = text.length();

        if (textLength < patternLength) {
            return textLength;
        }

        long textHash = hash(text);

        if (patternHash == textHash && check(text, 0)) {
            return 0;  // match
        }

        for (int textIndex = patternLength; textIndex < textLength; textIndex++) {
            // Remove leading character, add trailing character, check for match
            textHash = (textHash + largePrimeNumber - rm * text.charAt(textIndex - patternLength) % largePrimeNumber)
                    % largePrimeNumber;
            textHash = (textHash * alphabetSize + text.charAt(textIndex)) % largePrimeNumber;

            int offset = textIndex - patternLength + 1;

            if (patternHash == textHash && check(text, offset)) {
                return offset;  // match
            }
        }

        return textLength;      // no match
    }

    // Count the occurrences of pattern in the text
    public int count(String text) {
        int count = 0;

        int occurrenceIndex = searchFromIndex(text, 0);

        while (occurrenceIndex != text.length()) {
            count++;

            if (occurrenceIndex + 1 >= text.length()) {
                break;
            }

            occurrenceIndex = searchFromIndex(text, occurrenceIndex + 1);
        }

        return count;
    }

    // Finds all the occurrences of pattern in the text
    public Iterable<Integer> findAll(String text) {
        Queue<Integer> offsets = new Queue<>();

        int occurrenceIndex = searchFromIndex(text, 0);

        while (occurrenceIndex != text.length()) {
            offsets.enqueue(occurrenceIndex);

            if (occurrenceIndex + 1 >= text.length()) {
                break;
            }

            occurrenceIndex = searchFromIndex(text, occurrenceIndex + 1);
        }

        return offsets;
    }

    // Searches for the pattern in the text starting at specified index
    protected int searchFromIndex(String text, int textStartIndex) {
        String eligibleText = text.substring(textStartIndex);

        int textLength = eligibleText.length();

        if (textLength < patternLength) {
            return textStartIndex + textLength;  // no match
        }

        long textHash = hash(eligibleText);

        if (patternHash == textHash && check(eligibleText, 0)) {
            return textStartIndex;  // match
        }

        for (int textIndex = patternLength; textIndex < textLength; textIndex++) {
            // Remove leading character, add trailing character, check for match
            textHash = (textHash + largePrimeNumber - rm * eligibleText.charAt(textIndex - patternLength) % largePrimeNumber)
                    % largePrimeNumber;
            textHash = (textHash * alphabetSize + eligibleText.charAt(textIndex)) % largePrimeNumber;

            int offset = textIndex - patternLength + 1;

            if (patternHash == textHash && check(eligibleText, offset)) {
                return textStartIndex + offset;  // match
            }
        }

        return textStartIndex + textLength;      // no match
    }

    // Parameters example: AACAA AABRAACADABRAACAADABRA
    public static void main(String[] args) {
        String pattern = args[0];
        String text = args[1];

        RabinKarp rabinKarp = new RabinKarp(pattern, true);
        StdOut.println("text:    " + text);

        int offset = rabinKarp.search(text);
        StdOut.print("pattern: ");
        for (int i = 0; i < offset; i++) {
            StdOut.print(" ");
        }
        StdOut.println(pattern);
    }

}
```

#### 总结

- **暴力查找**算法的实现非常简单且在一般的情况下都工作良好;(Java 的String 类型的indexOf() 方法使用的就是暴力子字符串查找算法.)

- Knuth-Morris-Pratt 算法能够保证线性级别的性能且不需要在正文中回退；

- **Boyer-Moore** 算法的性能在一般情况下都是亚线性级别（可能是线性级别的M 倍）；

- **Rabin-Karp** 算法是线性级别。

每种算法也各有缺点：

- **暴力查找**算法所需的时间可能和MN 成正比；

- **Knuth-Morris-Pratt** 算法和**Boyer-Moore** 算法都需要额外的内存空间；

- **Rabin-Karp** 算法的内循环很长（若干次算术运算，而其他算法都只需要比较字符）

### 4.正则表达式

#### 正则表达式匹配器

```
public class RegularExpressionMatcher {

    protected class RangeComplement {
        protected char leftCharacter;
        protected char rightCharacter;

        RangeComplement(char leftCharacter, char rightCharacter) {
            this.leftCharacter = leftCharacter;;
            this.rightCharacter = rightCharacter;
        }
    }

    protected char[] regularExpression;  // Match transitions
    protected Digraph digraph;           // Epsilon transitions
    protected int numberOfStates;

    protected SeparateChainingHashTable<Integer, Integer> setsMatchMap;
    protected SeparateChainingHashTable<Integer, HashSet<Character>> setsComplementMap;
    protected SeparateChainingHashTable<Integer, List<RangeComplement>> setsComplementRangesMap;

    public RegularExpressionMatcher(String regularExpressionString) {
        // Create the nondeterministic finite automaton for the given regular expression
        Stack<Integer> operators = new Stack<>();
        regularExpression = regularExpressionString.toCharArray();
        numberOfStates = regularExpression.length;

        setsMatchMap = new SeparateChainingHashTable<>();
        setsComplementMap = new SeparateChainingHashTable<>();
        setsComplementRangesMap = new SeparateChainingHashTable<>();

        digraph = new Digraph(numberOfStates + 1);

        for (int i = 0; i < numberOfStates; i++) {
            int leftOperator = i;

            if (regularExpression[i] == '(' || regularExpression[i] == '|' || regularExpression[i] == '[') {
                operators.push(i);
            } else if (regularExpression[i] == ')') {
                leftOperator = handleRightParenthesis(operators, i);
            } else if (regularExpression[i] == ']') {
                leftOperator = operators.pop();
                handleSets(leftOperator, i);
            }

            if (i < numberOfStates - 1) {
                if (regularExpression[i + 1] == '*') {
                    digraph.addEdge(leftOperator, i + 1);
                    digraph.addEdge(i + 1, leftOperator);
                } else if (regularExpression[i + 1] == '+') {
                    digraph.addEdge(i + 1, leftOperator);
                }
            }

            if (regularExpression[i] == '(' || regularExpression[i] == '*' || regularExpression[i] == ')'
                    || regularExpression[i] == '+' || regularExpression[i] == '[' || regularExpression[i] == ']') {
                digraph.addEdge(i, i + 1);
            }
        }
    }

    private int handleRightParenthesis(Stack<Integer> operators, int index) {
        HashSet<Integer> orOperatorIndexes = new HashSet<>();

        while (regularExpression[operators.peek()] == '|') {
            int or = operators.pop();
            orOperatorIndexes.add(or);
        }

        int leftOperator = operators.pop();

        for (int orOperatorIndex : orOperatorIndexes.keys()) {
            digraph.addEdge(orOperatorIndex, index);
            digraph.addEdge(leftOperator, orOperatorIndex + 1);
        }

        return leftOperator;
    }

    private void handleSets(int leftSquareBracket, int index) {
        boolean isComplementSet = false;
        HashSet<Character> charactersToComplement = null;
        List<RangeComplement> rangesToComplement = null;

        // Handle complement set descriptors
        // If it is a complement operator, put all characters in a set to optimize the recognition later
        if (regularExpression[leftSquareBracket + 1] == '^') {
            isComplementSet = true;
            leftSquareBracket++; // No need to check this character in the next loop
            charactersToComplement = new HashSet<>();
            rangesToComplement = new ArrayList<>();

            for (int indexInsideBrackets = leftSquareBracket + 1; indexInsideBrackets < index; indexInsideBrackets++) {
                if (regularExpression[indexInsideBrackets + 1] == '-') {
                    char leftCharacter = regularExpression[indexInsideBrackets];
                    char rightCharacter = regularExpression[indexInsideBrackets + 2];

                    rangesToComplement.add(new RangeComplement(leftCharacter, rightCharacter));
                    indexInsideBrackets += 2;
                } else {
                    charactersToComplement.add(regularExpression[indexInsideBrackets]);
                }
            }
        }

        // Handle all set-of-character descriptors
        for (int indexInsideBrackets = leftSquareBracket + 1; indexInsideBrackets < index; indexInsideBrackets++) {
            digraph.addEdge(leftSquareBracket, indexInsideBrackets);

            // If a match occurs while checking the characters in this set, the DFA will go to
            // the right square bracket state.
            setsMatchMap.put(indexInsideBrackets, index);

            if (isComplementSet) {
                setsComplementMap.put(indexInsideBrackets, charactersToComplement);
                if (rangesToComplement.size() > 0) {
                    setsComplementRangesMap.put(indexInsideBrackets, rangesToComplement);
                }
            }

            // If it as a range, there is no need to process the next 2 characters
            if (regularExpression[indexInsideBrackets + 1] == '-') {
                indexInsideBrackets += 2;
            }
        }
    }

    public boolean recognizes(String text) {
        Bag<Integer> allPossibleStates = new Bag<>();
        DirectedDFS directedDFS = new DirectedDFS(digraph, 0);

        for (int vertex = 0; vertex < digraph.vertices(); vertex++) {
            if (directedDFS.marked(vertex)) {
                allPossibleStates.add(vertex);
            }
        }

        for (int i = 0; i < text.length(); i++) {
            // Compute possible NFA states for text[i + 1]
            Bag<Integer> states = new Bag<>();

            for (int vertex : allPossibleStates) {
                if (vertex < numberOfStates) {
                    if (setsMatchMap.contains(vertex)) {
                        recognizeSet(text, i, vertex, states);
                    } else if (regularExpression[vertex] == text.charAt(i) || regularExpression[vertex] == '.') {
                        states.add(vertex + 1);
                    }
                }
            }

            allPossibleStates = new Bag<>();
            directedDFS = new DirectedDFS(digraph, states);

            for (int vertex = 0; vertex < digraph.vertices(); vertex++) {
                if (directedDFS.marked(vertex)) {
                    allPossibleStates.add(vertex);
                }
            }

            // Optimization if no states are reachable
            if (allPossibleStates.size() == 0) {
                return false;
            }
        }

        for (int vertex : allPossibleStates) {
            if (vertex == numberOfStates) {
                return true;
            }
        }

        return false;
    }

    private void recognizeSet(String text, int index, int vertex, Bag<Integer> states) {
        int indexOfRightSquareBracket = setsMatchMap.get(vertex);

        // Is it a range?
        if (regularExpression[vertex + 1] == '-') { // No need to worry about out of bounds indexes
            char leftRangeIndex = regularExpression[vertex];
            char rightRangeIndex = regularExpression[vertex + 2];

            if (leftRangeIndex <= text.charAt(index) && text.charAt(index) <= rightRangeIndex) {
                if (!isCharPartOfComplementSet(text, index, vertex)) {
                    states.add(indexOfRightSquareBracket);
                }
            } else if (setsComplementMap.contains(vertex) && !isCharPartOfComplementSet(text, index, vertex)) {
                states.add(indexOfRightSquareBracket);
            }
        } else if (regularExpression[vertex] == text.charAt(index) || regularExpression[vertex] == '.') {
            if (!isCharPartOfComplementSet(text, index, vertex)) {
                states.add(indexOfRightSquareBracket);
            }
        } else if (setsComplementMap.contains(vertex) && !isCharPartOfComplementSet(text, index, vertex)) {
            states.add(indexOfRightSquareBracket);
        }
    }

    protected boolean isCharPartOfComplementSet(String text, int index, int vertex) {
        // Check complements map
        if (setsComplementMap.contains(vertex)
                && setsComplementMap.get(vertex).contains(text.charAt(index))) {
            return true;
        }

        // Check complement ranges map
        if (setsComplementRangesMap.contains(vertex)) {
            for (RangeComplement rangeComplement : setsComplementRangesMap.get(vertex)) {
                if (rangeComplement.leftCharacter <= text.charAt(index)
                        && text.charAt(index) <= rangeComplement.rightCharacter) {
                    return true;
                }
            }
        }

        return false;
    }
}
```

### 5.数据压缩

#### Genome

```
public class Genome {

    public static void compress() {
        Alphabet DNA = Alphabet.DNA;
        String string = BinaryStdIn.readString();
        int length = string.length();

        BinaryStdOut.write(length);

        for (int i = 0; i < length; i++) {
            // Write two-bit code for char
            int code = DNA.toIndex(string.charAt(i));
            BinaryStdOut.write(code, DNA.lgR());
        }
        BinaryStdOut.close();
    }

    public static void expand() {
        Alphabet DNA = Alphabet.DNA;
        int width = DNA.lgR();
        int length = BinaryStdIn.readInt();

        for (int i = 0; i < length; i++) {
            // Read 2 bits; write char
            char character = BinaryStdIn.readChar(width);
            BinaryStdOut.write(DNA.toChar(character), 8);
        }
        BinaryStdOut.close();
    }

    public static void main(String[] args) {
        if (args[0].equals("-")) {
            compress();
        } else if (args[0].equals("+")) {
            expand();
        }
    }

}
```

#### 游程编码

```
public class RunLengthEncoding {

    private static final int LG_R = 8;

    public static void compress() {
        char count = 0;
        boolean old = false;

        while (!BinaryStdIn.isEmpty()) {
            boolean bit = BinaryStdIn.readBoolean();

            if (bit != old) {
                BinaryStdOut.write(count, LG_R);
                count = 0;
                old = !old;
            } else {
                if (count == 255) {
                    BinaryStdOut.write(count, LG_R);
                    count = 0;
                    BinaryStdOut.write(count, LG_R);
                }
            }
            count++;
        }

        BinaryStdOut.write(count);
        BinaryStdOut.close();
    }

    public static void expand() {
        boolean bit = false;

        while (!BinaryStdIn.isEmpty()) {
            char count = BinaryStdIn.readChar();

            for (int i = 0; i < count; i++) {
                BinaryStdOut.write(bit);
            }
            bit = !bit;
        }

        BinaryStdOut.close();
    }

    public static void main(String[] args) {
        if (args[0].equals("-")) {
            compress();
        } else if (args[0].equals("+")) {
            expand();
        }
    }

}
```

#### 霍夫曼编码

```Java
public class Huffman {

    // Huffman trie node
    private static class Node implements  Comparable<Node> {
        private char character; // unused for internal nodes
        private int frequency;  // unused for expand
        private final Node left;
        private final Node right;

        Node(char character, int frequency, Node left, Node right) {
            this.character = character;
            this.frequency = frequency;
            this.left = left;
            this.right = right;
        }

        public boolean isLeaf() {
            return left == null && right == null;
        }

        public int compareTo(Node that) {
            return this.frequency - that.frequency;
        }
    }

    private static final int R = 256; // ASCII alphabet

    public static void compress() {
        // Read input
        String string = BinaryStdIn.readString();
        char[] input = string.toCharArray();

        // Tabulate frequency counts
        int[] frequencies = new int[R];
        for (int i = 0; i < input.length; i++) {
            frequencies[input[i]]++;
        }

        // Build Huffman code trie
        Node root = buildTrie(frequencies);

        // Build code table
        String[] codeTable = new String[R];
        buildCode(codeTable, root, "");

        // Print trie for decoder
        writeTrie(root);

        // Print number of characters
        BinaryStdOut.write(input.length);

        // Use Huffman code to encode input
        for (int i = 0; i < input.length; i++) {
            String codeword = codeTable[input[i]];

            for (int j = 0; j < codeword.length(); j++) {
                if (codeword.charAt(j) == '0') {
                    BinaryStdOut.write(false);
                } else if (codeword.charAt(j) == '1') {
                    BinaryStdOut.write(true);
                } else {
                    throw new IllegalStateException("Illegal state");
                }
            }
        }

        BinaryStdOut.close();
    }

    private static Node buildTrie(int[] frequencies) {
        PriorityQueueResize<Node> priorityQueue = new PriorityQueueResize<>(PriorityQueueResize.Orientation.MIN);

        for (char character = 0; character < R; character++) {
            if (frequencies[character] > 0) {
                priorityQueue.insert(new Node(character, frequencies[character], null, null));
            }
        }

        // Special case in case there is only one character with a nonzero frequency
        if (priorityQueue.size() == 1) {
            if (frequencies['\0'] == 0) {
                priorityQueue.insert(new Node('\0', 0, null, null));
            } else {
                priorityQueue.insert(new Node('\1', 0, null, null));
            }
        }

        while (priorityQueue.size() > 1) {
            // Merge two smallest trees
            Node tree1 = priorityQueue.deleteTop();
            Node tree2 = priorityQueue.deleteTop();

            Node parent = new Node('\0', tree1.frequency + tree2.frequency, tree1, tree2);
            priorityQueue.insert(parent);
        }

        return priorityQueue.deleteTop();
    }

    private static String[] buildCode(Node root) {
        // Make a lookup table from trie
        String[] codeTable = new String[R];
        buildCode(codeTable, root, "");
        return codeTable;
    }

    private static void buildCode(String[] codeTable, Node node, String string) {
        if (node.isLeaf()) {
            codeTable[node.character] = string;
            return;
        }

        buildCode(codeTable, node.left, string + '0');
        buildCode(codeTable, node.right, string + '1');
    }

    private static void writeTrie(Node node) {
        // Write bitstring-encoded trie
        if (node.isLeaf()) {
            BinaryStdOut.write(true);
            BinaryStdOut.write(node.character, 8);
            return;
        }

        BinaryStdOut.write(false);
        writeTrie(node.left);
        writeTrie(node.right);
    }

    public static void expand() {
        Node root = readTrie();
        int length = BinaryStdIn.readInt();

        for (int i = 0; i < length; i++) {
            // Expand ith codeword
            Node node = root;

            while (!node.isLeaf()) {
                if (BinaryStdIn.readBoolean()) {
                    node = node.right;
                } else {
                    node = node.left;
                }
            }

            BinaryStdOut.write(node.character, 8);
        }

        BinaryStdOut.close();
    }

    private static Node readTrie() {
        boolean isLeaf = BinaryStdIn.readBoolean();

        if (isLeaf) {
            return new Node(BinaryStdIn.readChar(), 0, null, null);
        } else {
            return new Node('\0', 0, readTrie(), readTrie());
        }
    }

}
```

#### LZW

```java
public class LZW {

    private static final int R = 256;  // Number of input characters
    private static final int W = 12;   // Codeword width
    private static final int L = 4096; // Number of codewords = 2^W

    public static void compress() {
        String input = BinaryStdIn.readString();
        TernarySearchTrie<Integer> ternarySearchTrie = new TernarySearchTrie<>();

        for (int i = 0; i < R; i++) {
            ternarySearchTrie.put(String.valueOf((char) i), i);
        }

        int codeword = R + 1; // R is the codeword for EOF

        while (input.length() > 0) {
            String key = ternarySearchTrie.longestPrefixOf(input); // Find max prefix match
            BinaryStdOut.write(ternarySearchTrie.get(key), W); // Print key's encoding

            int length = key.length();
            if (length < input.length() && codeword < L) {
                ternarySearchTrie.put(input.substring(0, length + 1), codeword); // Add key to symbol table
                codeword++;
            }

            input = input.substring(length);
        }

        BinaryStdOut.write(R, W); // Write EOF
        BinaryStdOut.close();
    }

    public static void expand() {
        String[] codeTable = new String[L];

        int nextCodeword;

        // Initialize code table with all 1-character strings
        for (nextCodeword = 0; nextCodeword < R; nextCodeword++) {
            codeTable[nextCodeword] = String.valueOf((char) nextCodeword);
        }
        codeTable[nextCodeword++] = ""; // (unused) lookahead for EOF

        int codeword = BinaryStdIn.readInt(W);

        if (codeword == R) {
            return;
        }

        String value = codeTable[codeword];

        while (true) {
            BinaryStdOut.write(value); // Write current substring
            codeword = BinaryStdIn.readInt(W);

            if (codeword == R) {
                break;
            }

            String string = codeTable[codeword]; // Get next string

            // Check if lookahead is invalid
            if (nextCodeword == codeword) {
                string = value + value.charAt(0); // If it is, make codeword from last one
            }

            if (nextCodeword < L) {
                codeTable[nextCodeword++] = value + string.charAt(0); // Add new entry to code table
            }

            value = string; // Update current value
        }

        BinaryStdOut.close();
    }

}
```

## 完结

完结撒花🎉🎉🎉